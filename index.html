<!DOCTYPE html>
<html>
    <head>
      <title>Control Features</title>
      <link href="/admin.css" rel="stylesheet">
      <link href="/list.css" rel="stylesheet">
      <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
      <script crossorigin="anonymous" integrity="sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head>
    <body>
      <h1>SRFI 226: Control Features</h1>
      <p class="authors">by Marc Nieper-Wißkirchen</p>
      <p class="based-on"></p>
      <p class="status">status: <em>draft</em> (2021-08-06)</p>
      <p class="keywords">keywords: <a href="https://srfi.schemers.org/?keywords=continuations">Continuations</a>, <a href="https://srfi.schemers.org/?keywords=control-flow">Control Flow</a></p><span class="see-also">See also <a href="/srfi-18/">SRFI 18: Multithreading support</a>, <a href="/srfi-34/">SRFI 34: Exception Handling for Programs</a>, <a href="/srfi-39/">SRFI 39: Parameter objects</a>, <a href="/srfi-45/">SRFI 45: Primitives for Expressing Iterative Lazy Algorithms</a>, <a href="/srfi-97/">SRFI 97: SRFI Libraries</a>, <a href="/srfi-154/">SRFI 154: First-class dynamic extents</a>, <a href="/srfi-155/">SRFI 155: Promises</a>, <a href="/srfi-157/">SRFI 157: Continuation marks</a>, and <a href="/srfi-158/">SRFI 158: Generators and Accumulators</a>.</span>
      <ul class="info">
        <li><a href="srfi-226.html">The SRFI Document</a></li>
        <li><a href="https://srfi-email.schemers.org/srfi-226/">Discussion Archive</a></li>
        <li><a href="https://github.com/scheme-requests-for-implementation/srfi-226">Git repo (on GitHub)</a></li>
        <li><a href="mailto:srfi-226@srfi.schemers.org">srfi-226@<span class="antispam">nospam</span>srfi.schemers.org (subscribers only)</a></li>
        <li><span class="firefox-column-workaround">
            <form method="POST" action="https://www.simplelists.com/subscribe.php">
              <div class="title">Subscribe to srfi-226 mailing list</div><input name="email" placeholder="email address" tabindex="1" type="email"><input name="name" placeholder="full name" tabindex="2" type="text">
              <p><input id="sub-digest" name="digest" tabindex="3" type="checkbox" value="digest"><label for="sub-digest">daily digest?</label></p><input class="submit" name="submit" tabindex="4" type="submit" value="Subscribe to srfi-226"><input type="hidden" name="action" value="subscribe"><input type="hidden" name="list" value="srfi-226@srfi.schemers.org"></form></span></li>
        <li><span class="firefox-column-workaround">
            <form method="POST" action="https://www.simplelists.com/subscribe.php">
              <div class="title">Unsubscribe from srfi-226 mailing list</div><input name="email" placeholder="email address" tabindex="5" type="email"><input class="submit" name="submit" tabindex="6" type="submit" value="Unsubscribe from srfi-226"><input type="hidden" name="action" value="unsubscribe"><input name="list" type="hidden" value="srfi-226@srfi.schemers.org"></form></span></li></ul>
      <h2>Abstract</h2>    <p>Whenever an expression is evaluated during the run of a Scheme program,
    there is a continuation awaiting the values of the expression. It is a
    distinguishing property of the Scheme programming language to offer a
    procedure (named <code>call/cc</code>) that captures the current
    continuation as a procedure, which, when called, aborts the then current
    continuation and reinstates the captured one.</p>

    <p>One can visualize a continuation as a list of (continuation) frames
      where a non-tail call adds a frame to the top of the list and where the return
      from a non-tail call removes the appropriate frame.</p>

    <p>Moreover, each expression is evaluated in a dynamic environment that
      conceptually holds the values of parameters like the current output port
      and the dynamic-wind stack at the point of evaluation.  As the dynamic
      environment is captured and reinstated along the continuation when the
      <code>call/cc</code> machinery is used, we can view it conceptually as
      part of the continuation.</p>

    <p>The libraries defined in this SRFI are all concerned with continuations
      in a wider sense. More specifically, the topics are as follows:</p>

    <p><i>Continuation Prompts:</i> A continuation prompt is a special
    continuation frame, which is tagged with a so-called prompt tag. Procedures
    to install continuation prompts and to abort the current continuation and
    to escape back to a previously installed continuation prompt are
    provided. Moreover, continuation prompts are equipped with handlers that
    are invoked when a continuation is aborted to them.</p>

    <p><i>Continuations:</i> When continuations are captured, the list of
    captured continuation frames are always delimited by some continuation
    prompt. This extends the semantics of Scheme’s
    <code>call-with-current-continuation</code>.  Moreover, a
    procedure to capture so-called composable continuations is
    provided. As opposed to continuations captured
    by <code>call-with-current-continuation</code>, invoking a
    composable continuation does not abort the then current
    continuation, so composable continuations behave like ordinary
    procedures.  Together with continuation prompts, composable
    continuations allow one to implement the various proposed sets of
    control operators for delimited continuations. Finally, a
    primitive (<code>call-in-continuation</code>) is provided that
    allows calling a procedure in a given continuation instead of just
    delivering values to it.</p>

    <p><i>Continuation Marks:</i> Continuation marks are a provided feature
      that allows one to attach arbitrary information to continuation frames,
      which are captured and reinstated along the rest of the
      continuation. Conceptually, exception handlers and parameters are
      implemented in terms of continuation marks, but the syntax and procedures
      defined in this SRFI allow the user to use them in more general
      ways. Moreover, they reify the notion of a tail call, allowing, for
      example, to test for tail context.</p>

    <p><i>Exceptions:</i> The exception mechanism
    of <a href="https://doi.org/10.1017/S0956796809990074">R6RS</a>
    and <a href="https://small.r7rs.org/attachment/r7rs.pdf"><cite>R7RS</cite></a> is reinterpreted with
    respect to the concepts introduced in this SRFI.  Moreover, the
    <code>with-exception-handler</code> procedure and the <code>guard</code>
    syntax gain additional tail context guarantees.</p>

    <p><i>Parameters:</i> The parameter object mechanism
    of <a href="#feeley2"><cite>SRFI 39</cite></a>
    and <cite>R7RS</cite> is reinterpreted with respect to the
    concepts introduced in this SRFI.  Procedures to retrieve the
    current parameterization and to reinstall it later are
    provided. Moreover, the <code>parameterize</code> syntax gains an
    additional tail context guarantee.  To support an alternative
    model of parameters that is linked to the dynamic extent and not
    to the current parameterization, the notion of a parameter-like
    object and the <code>with</code> syntax are introduced.</p>

    <p><i>Fluids:</i> Fluids are a syntactic reinterpretation of parameter
      objects.</p>

    <p><i>Delayed evaluation:</i> The syntax and procedures on delayed
      evaluation of <cite>R7RS</cite> are revisited and redefined to handle the
      following satisfactorily: the parameterization of the delayed expression
      being forced, the treatment of exceptions raised during forcing of
      delayed expressions, and iterative lazy algorithms. Moreover, their
      semantics are detailed with respect to the concepts introduced in this
      SRFI, and promises can naturally deliver an arbitrary number of values
      when being forced. Finally, the initial continuation of a delayed
      expression being forced is defined in a way that makes it interchangeably
      with the initial continuation of a thread.</p>

    <p><i>Threads:</i> The thread mechanism
      of <a href="https://srfi.schemers.org/srfi-18/srfi-18.html"><cite>SRFI 18</cite></a> is detailed with
      respect to the concepts introduced in this SRFI.  In particular,
      mutation of parameter objects in multi-threaded applications is
      specified.  In order to support timeout arguments in a type-safe
      way, a minimal API on time objects is included as well.</p>

    <p>Large parts of this SRFI have been inspired by the control operators
      provided by <a href="https://racket-lang.org/"><cite>Racket</cite></a>.</body></html>