<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI XXX: Control Operators</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body
      {
	  font-family: serif;
      }
      span.token
      {
          font-family: serif;
      }
      span.token::before
      {
          content: "〈";
      }
      span.token::after
      {
          content: "〉";
      }
      dl.entries dt
      {
	  background-color: lightgrey;
      }
      dl.entries dd
      {
	  margin-left: 0;
      }
      dl.entries > dt.condition-type::after
      {
	  float: right;
	  content: "condition type"
      }
      dl.entries > dt.procedure::after
      {
	  float: right;
	  content: "procedure"
      }
      dl.entries > dt.syntax::after
      {
	  float: right;
	  content: "syntax"
      }
      pre, code
      {
	  font-size: smaller;
      }
      </style>
  </head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>XXX: Control Operators</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <h2 id="abstract">Abstract</h2>

    <p>This SRFI defines a rich set of control operators, which has
      originally been implemented in this form in Racket, for the
      Scheme programming language.  This set includes the
      venerable <code>call/cc</code>.</p>

    <p>Prompts delimit continuations,
      and all continuations are conceptually delimited, at the latest
      by the default prompt at the start of each thread.  Instead, continuations
      are divided into composable and non-composable continuations.</p>

    <p>To investigate continuations, this SRFI supports continuation
      marks and offers operators to set and retrieve them.</p>

    <h2 id="issues">Issues</h2>

    <p>None at present.</p>

    <h2 id="rationale">Rationale</h2>

    <p>The aim of this SRFI is to provide a consistent set of control
      operators vastly extending the scope of the venerable pair
      of <code>call/cc</code> and <code>dynamic-wind</code>.  The
      procedures and syntax in this SRFI can be presented as an
      R<sup>6</sup>RS or as an R<sup>7</sup>RS library, which would be
      named <code>(srfi :XXX control)</code> or <code>(srfi
      XXX)</code>, respectively.  Although a portable implementation
      is not possible, it is demonstrated by the sample implementation
      that a small set of primitives, which can easily be provided by
      any Scheme implementation, suffices to implement the rich
      operators in this SRFI.</p>

    <p>In detail, the contributions of this SRFI are the following:</p>

    <h3>Delimited Continuations and Prompts</h3>

    TBD

    <h3>Composable and Non-Composable Continuations</h3>

    TBD

    <h3>Continuation Marks</h3>

    TBD

    <h3>Continuations and Threads</h3>

    TBD

    <h2 id="specification">Specification</h2>

    <h3>Entry format</h3>

    <p>The following naming conventions imply type restrictions:</p>

    <dl>
      <dt><code><var>obj</var></code></dt>
      <dd>any object</dd>
      <dt><code><var>thunk</var></code></dt>
      <dd>zero-argument procedure </dd>
      <dt><code><var>cont</var></code></dt>
      <dd>continuation</dd>
      <dt><code><var>prompt-tag</var></code></dt>
      <dd>Prompt tag</dd>
      <dt><code><var>handler</var></code></dt>
      <dd>procedure or <code>#f</code></dd>
      <dt><code><var>k</var></code></dt>
      <dd>undelimited continuation</dd>
    </dl>

    <h3>Conditions</h3>

    <dl class="entries">
      <dt class="condition-type"><code>&continuation</code></dt>
      <dt class="procedure"><code>(make-continuation-condition <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-condition? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-prompt-tag <var>condition</var></code>)</dt>
      <dd>
	<p>
	  This condition type could be defined by
	</p>
	<pre>(define-condition-type &continuation &error
  make-continuation-condition continuation-condition?
  (prompt-tag continuation-prompt-tag))</pre>
	<p>
	  This condition type describes errors that occurred during
	  non-local control
	  operations.  <code><var>Prompt-tag</var></code> should be
	  the tag of the delimiting prompt.</p>
      </dd>
    </dl>

    <h3>Continuation Prompts</h3>

    <p>Continuation prompts are tagged with <dfn>prompt tags</dfn>,
      which are opaque values.</p>

    <dl class="entries">
      <dt><code>(call-with-continuation-prompt <var>thunk</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var> <var>handler</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	  defaults to the value returned
	  by <code>(default-continuation-prompt-tag)</code>,
	  and <code><var>handler</var></code> defaults
	  to <code>#f</code>.</p>

	<p>
	  The <code>call-with-continuation-prompt</code> procedure
	  calls <code><var>thunk</var></code> without arguments,
	  returning the results of this call.
	  Moreover, <code>call-with-continuation-prompt</code> tags
	  the dynamic extent of the call
	  to <code><var>thunk</var></code>
	  with <code><var>prompt-tag</var></code> and
	  records <code><var>handler</var></code> with the prompt
	  if <code><var>handler</var></code> is not <code>#f</code>,
	  and with a default handler otherwise.
	</p>

	<p>The default handler is a procedure that takes a single
	  argument <code><var>thunk</var></code>.  When the default
	  handler is called, it calls <code><var>thunk</var></code>
	  without arguments, returning the results of this code.
	  Moreover, the default handler tags the dynamic extent of the
	  call to <code><var>thunk</var></code>
	  with <code><var>prompt-tag</var></code> and records itself
	  with the prompt.</p>

	<p>The calls to <code><var>thunk</var></code> are never in tail
	context.</p>
      </dd>

      <dt><code>(abort-current-continuation <var>prompt-tag</var> <var>obj<var>
      &hellip;)</code></dt>
      <dd>
	<p>The <code>abort-current-continuation</code> procedure
	  aborts all active procedure calls in the current
	  continuation until a procedure call whose dynamic extent is
	  tagged with <code><var>prompt-tag</var></code> is aborted
	  and replaces them with a call to the handler recorded with
	  the prompt tag with the arguments <code><var>obj</var></code>s.</p>
	<p>
	  When no procedure call whose dynamic extent is tagged
	  with <code><var>prompt-tag</var></code> is active in the current
	  continuation, an exception with condition
	  type <code>&continuation</code> is raised.</p>
      </dd>
    </dl>


    <h3>Continuations</h3>

    <p>Each <dfn>continuation</dfn> is a procedure.</p>

    <p><code>(continuation? <var>obj</var>)</code></p>

    <p>Returns <code>#t</code> if <code><var>obj</var></code> is a
      continuation, and <code>#f</code> otherwise.</p>

    <p><i>Note:</i> If the procedure <code>continuation?</code>
    returns <code>#t</code> when applied to an
    object <code><var>obj</var></code>, <code>procedure?</code> also
    returns <code>#t</code> when applied
    to <code><var>obj</var></code>.</p>

    <code>(call/cc (lambda (k) (continuation? k)))</code> &xrArr; <code>#t</code>

    <h2 id="implementation">Implementation</h2>

    <p>Implementing the control operators presented in this SRFI as a
      portable R6RS or portable R7RS library is not possible.</p>

    <p>The sample implementation accompanying this SRFI demonstrates
      how the control operators can be implemented on top of a small set of primitives:</p>

    <dl class="entries">
      <dt class="procedure"><code>(%call/cc <var>proc</var>)</code></dt>
      <dd>
	<p>It is an error if <code><var>proc</var></code> is not a
	procedure taking a single argument.</p>
	<p>Calls <code><var>proc</var></code> with the current undelimited continuation.</p>
	<p>If a call to <code>%call/cc</code> occurs in a tail
	context, the call to <code><var>proc</var></code> is also in a
	  tail context.</p>
	<p>Undelimited continuations are represented by procedures <code><var>k</var></code>
	  so that ...

	  , when called, abandon whatever
	  undelimited continuation is in effect at that time and
	  instead reinstates

	  invoke the undelimited
	  continuation.</p>
	<p>Continuation barriers and <code>dynamic-wind</code> thunks
	  are ignored.</p>
      </dd>
      <dt class="procedure"><code>(%call-in-continuation <var>k</var> <var>proc</var>)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>
      <dt class="procedure"><code>(%continuation=? <var>k<sub>1</sub></var> <var>k<sub>2</sub></var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if the undelimited continuation
	  represented by <code><var>k<sub>1</sub></var></code> is the
	  same as the undelimited continuation represented
	  by <code><var>k<sub>2</sub></var></code>,
	  and <code>#f</code> otherwise.</p>
	<p><i>Note:</i> Procedure equivalence with respect to the
	  standard predicates <code>eq?</code>, <code>eqv?</code>,
	  and <code>equal?</code> is unspecified at least in some
	  versions of the Scheme programming language.</p>
      </dd>

      <dt class="procedure"><code>(%procedure-specific <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>

      <dt class="procedure"><code>(%procedure-specific-set! <var>proc</var> <var>obj</var>)</code></dt> <dd>
	<p>TBD</p>
      </dd>

    </dl>

    <p>The sample implementation favors clarity over speed.</p>

    <p>The control operators of this SRFI are natively implemented in Racket.</p>

    <a href="srfi-minus-???-sample.scm">Source for the sample implementation.</a>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>This SRFI borrows heavily from Racket's control operators.  The
    sample implementation builds upon the ideas presented
    in <cite>Dybvig/Jones/Sabry: A Monadic Framework for Delimited
    Continuations.</p>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2021 Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
