<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 226: Control Features</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body
      {
	  counter-reset: section;
	  font-family: serif;
      }
      h2
      {
	  counter-reset: subsection;
      }
      h2::before
      {
	  counter-increment: section;
	  content: counter(section) " ";
      }
      h3
      {
	  counter-reset: subsubsection;
      }
      h3::before
      {
	  counter-increment: subsection;
	  content: counter(section) "." counter(subsection) " ";
      }
      h4::before
      {
	  counter-increment: subsubsection;
	  content: counter(section) "." counter(subsection) "." counter(subsubsection) " ";
      }
      span.token
      {
          font-family: serif;
      }
      span.token::before
      {
          content: "⟨";
      }
      span.token::after
      {
          content: "⟩";
      }
      dl.entries dt
      {
	  background-color: lightgrey;
      }
      dl.entries dd
      {
	  margin-left: 0;
      }
      dl.entries > dt.condition-type::after
      {
	  float: right;
	  content: "condition type"
      }
      dl.entries > dt.procedure::after
      {
	  float: right;
	  content: "procedure"
      }
      dl.entries > dt.syntax::after
      {
	  float: right;
	  content: "syntax"
      }
      dt.entry > span.type
      {
	  float: right;
      }
      pre, code
      {
	  font-size: smaller;
      }
      pre.example
      {
	  margin-left: 1em;
	  margin-right: 1em;
      }
      pre.example > span.result
      {
	  float: right;
      }
      pre.example > span.result::before
      {
	  padding-left: 1em;
	  padding-right: 1em;
	  content: "⟹"
      }
      sup
      {
	  display: inline-block;
      }
      </style>
  </head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>226: Control Features</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+226+at+srfi+dotschemers+dot+org">srfi-226@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-226">archive</a>.</p>
    <ul>
      <li>Received: 2021-08-06</li>
      <li>Draft #1 published: 2021-08-12</li>
      <li>Draft #2 published: 2022-09-09</li>
      <li>60-day deadline: 2021-10-11</li>
      <li>Marc Nieper-Wißkirchen's <a href="https://github.com/mnieper/srfi-226">personal
	Git repo for this SRFI</a> for reference while the SRFI is in
	<em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/mnieper/srfi-226/blob/master/srfi-226.html">preview</a>)</li>
    </ul>

    <h2 id="abstract">Abstract</h2>

    <p>Whenever an expression is evaluated during the run of a Scheme program,
    there is a continuation awaiting the values of the expression. It is a
    distinguishing property of the Scheme programming language to offer a
    procedure (named <code>call/cc</code>) that captures the current
    continuation as a procedure, which, when called, aborts the then current
    continuation and reinstates the captured one.</p>

    <p>One can visualize a continuation as a list of (continuation) frames
      where a non-tail call adds a frame to the top of the list and where the return
      from a non-tail call removes the appropriate frame.</p>

    <p>Moreover, each expression is evaluated in a dynamic environment that
      conceptually holds the values of parameters like the current output port
      and the dynamic-wind stack at the point of evaluation.  As the dynamic
      environment is captured and reinstated along the continuation when the
      <code>call/cc</code> machinery is used, we can view it conceptually as
      part of the continuation.</p>

    <p>The libraries defined in this SRFI are all concerned with continuations
      in a wider sense. More specifically, the topics are as follows:</p>

    <p><i>Continuation Prompts:</i> A continuation prompt is a special
    continuation frame, which is tagged with a so-called prompt tag. Procedures
    to install continuation prompts and to abort the current continuation and
    to escape back to a previously installed continuation prompt are
    provided. Moreover, continuation prompts are equipped with handlers that
    are invoked when a continuation is aborted to them.</p>

    <p><i>Continuations:</i> When continuations are captured, the list of
    captured continuation frames are always delimited by some continuation
    prompt. This extends the semantics of Scheme’s
    <code>call-with-current-continuation</code>.  Moreover, a
    procedure to capture so-called composable continuations is
    provided. As opposed to continuations captured
    by <code>call-with-current-continuation</code>, invoking a
    composable continuation does not abort the then current
    continuation, so composable continuations behave like ordinary
    procedures.  Together with continuation prompts, composable
    continuations allow one to implement the various proposed sets of
    control operators for delimited continuations. Finally, a
    primitive (<code>call-in-continuation</code>) is provided that
    allows calling a thunk in a given continuation instead of just
    delivering values to it.</p>

    <p><i>Continuation Marks:</i> Continuation marks are a provided feature
      that allows one to attach arbitrary information to continuation frames,
      which are captured and reinstated along the rest of the
      continuation. Conceptually, exception handlers and parameters are
      implemented in terms of continuation marks, but the syntax and procedures
      defined in this SRFI allow the user to use them in more general
      ways. Moreover, they reify the notion of a tail call, allowing, for
      example, to test for tail context.</p>

    <p><i>Exceptions:</i> The exception mechanism
    of <a href="#sperber"><cite>R6RS</cite></a>
    and <a href="#shinn"><cite>R7RS</cite></a> is reinterpreted with
    respect to the concepts introduced in this SRFI.  Moreover, the
    <code>with-exception-handler</code> procedure and the <code>guard</code>
    syntax gain additional tail context guarantees.</p>

    <p><i>Parameters:</i> The parameter object mechanism
    of <a href="#feeley2"><cite>SRFI 39</cite></a>
    and <cite>R7RS</cite> is reinterpreted with respect to the
    concepts introduced in this SRFI.  Procedures to retrieve the
    current parameterization and to reinstall it later are
    provided. Moreover, the parameterize syntax gains an additional
    tail context guarantee.</p>

    <p><i>Delayed evaluation:</i> The syntax and procedures on delayed
      evaluation of <cite>R7RS</cite> are revisited and redefined to handle the
      following satisfactorily: the parameterization of the delayed expression
      being forced, the treatment of exceptions raised during forcing of
      delayed expressions, and iterative lazy algorithms. Moreover, their
      semantics are detailed with respect to the concepts introduced in this
      SRFI, and promises can naturally deliver an arbitrary number of values
      when being forced. Finally, the initial continuation of a delayed
      expression being forced is defined in a way that makes it interchangeably
      with the initial continuation of a thread.</p>

    <p><i>Threads:</i> The thread mechanism of <a href="#feeley1"><cite>SRFI
      18</cite></a> is detailed with respect to the concepts introduced in this
      SRFI.  In particular, mutation of parameter objects in multithreaded
      applications is specified..</p>

    <p>Large parts of this SRFI have been inspired by the control operators
      provided by <a href="#racket"><cite>Racket</cite></a>.

    <h2 id="issues">Issues</h2>

    <ul>
      <li><p>A brief table of contents should be added before the
	  final draft.</p></li>
    </ul>

    <h2 id="rationale">Rationale</h2>

    <p>The aim of this SRFI is to provide a consistent set of control
      operators and related syntax and procedures vastly extending the
      scope of the venerable pair of <code>call/cc</code>
      and <code>dynamic-wind</code>.  The procedures and syntax in
      this SRFI can be provided as
      <a href="#sperber"><cite>R<sup>6</sup>RS</cite></a> or as
      <a href="#shinn"><cite>R<sup>7</sup>RS</cite></a> libraries.
      Although a portable implementation is not possible, it is
      demonstrated by the sample implementation that
      a <a href="#sample-implementation">small set of primitives</a>,
      which can easily be provided by any Scheme implementation,
      suffices to implement the rich operators in this SRFI.</p>

    <p>The theoretical concepts behind the operators described in this
      specification are well understood and not new.  The author of this SRFI
      does not claim any originality for any idea presented here, but is lucky
      to be able to stand on the shoulders of giants.  (See the various
      references in <a href="#dybvig"><cite>A Monadic Framework for Delimited
      Continuations</cite></a>, for example.)</p>

    <p>Whenever this document refers to just <cite>R<sup>7</sup>RS</cite>,
      the small language is meant as the large language is still a work in
      progress as the time of writing of this SRFI.</p>

    <h3>Overview</h3>

    <p>In detail, the contributions of this SRFI are the following:</p>

    <h4>Continuations and Prompts</h4>

    <p>As explained in <cite>R<sup>6</sup>RS</cite> and
      <cite>R<sup>7</sup>RS</cite>, whenever a Scheme expression is evaluated,
       there is a <dfn>continuation</dfn> wanting the result of the expression.
       We can view a continuation as a sequence of active procedure calls.
       Evaluation steps alter the current continuation.  Calls add an active
       procedure call to the current continuation, while returns remove an
       active procedure call.
    </p>

    <p>Certain control operations can change the current continuation
      more radically.  The Scheme procedure <code>call/cc</code>
      allows capturing the current continuation and reifies it into a
      procedure that, when later called, abandons the then-current
      continuation and replaces it with the captured one.</p>

    <p>Conceptually, only an end segment of the current continuation is ever
      replaced.  For example, when running a Scheme program, running a thread,
      or evaluating an expression at the REPL prompt, the old and the new
      current continuation always share an initial segment at least up to the
      point when the program was started, the thread was started, or the
      expression was sent to the REPL.</p>

    <p>Therefore, <code>call/cc</code> never has to, nor actually does,
      capture the whole current continuation, but only an end segment.
      Reinstating the captured continuation means to replace the end
      segment of the then-current continuation.</p>

    <p>With <code>call/cc</code> alone, the programmer has no control over the
      size of this end segment.  This SRFI offers operators to do exactly this.
      With these operators, the programmer can install <dfn>continuation
      prompts</dfn> identified by <dfn>prompt tags</dfn> in the current
      continuation.  When a continuation is later captured, it is delimited by
      the nearest continuation prompt with a given prompt tag.  Default prompts
      are installed at the start of each program, the start of each thread, and
      when promises are forced.</p>

    <p>The reason that continuation prompts are called <i>prompts</i>
      is that ​a continuation as we know from Scheme is usually
      delimited at the <i>prompt</i> of the REPL.  In a strict sense,
      an undelimited continuation does not return by definition.  But
      this is not true for an actual continuation returned by even the
      venerable <code>call/cc</code>.  When it is invoked, it will
      deliver value at the REPL prompt.  (And when the program may not
      have been running from a REPL, the prompt is that of the shell
      or some HALT instruction.)  A <i>prompt</i> as defined by this
      document just extends this scenario.</p>

    <h4>Composable and Non-Composable Continuations</h4>

    <p>When a continuation captured
      with <code>call-with-current-continuation</code> is later
      invoked, the invocation never returns to this call's
      continuation.  In this sense, such a continuation procedure is
      far from being a function in the mathematical sense, as it
      doesn't deliver any values.  In particular, it cannot be
      composed.  For that reason, continuations captured
      by <code>call-with-current-continuation</code> are also
      called <dfn>non-composable continuations</dfn>.</p>

    <p>This SRFI offers an
      operator <code>call-with-composable-continuation</code> that also captures
      the current continuation, but reifies it into a different type of
      continuation, a <dfn>composable continuation</dfn>.  Contrary to
      non-composable continuations, a composable continuation, when invoked,
      does not abort any active procedure call, but just extends the then-current
      continuation.  In particular, it delivers values to the
      continuation of the call to it.  A composable continuation therefore
      behaves like an ordinary procedure.</p>

    <h4>Continuation Marks</h4>

    <p><dfn>Continuation marks</dfn> are a feature that allows attaching
      information in the form of key-value pairs to individual continuation
      frames, which are maximal segments of continuations of a number of active
      tail calls followed by at most one active non-tail call.  The set of
      continuation marks of the continuation frames of a continuation belongs
      to this continuation and is thus also captured
      by <code>call-with-current-continuation</code>
      and <code>call-with-composable-continuation</code>.</p>

    <p>Continuation marks can be used to implement exception handlers,
      parameter objects, and an implementation of <code>delay</code>
      and <code>force</code> of <a href="#kelsey1"><cite>R<sup>5</sup>RS</cite></a>
      that supports iterative lazy algorithms.</p>

    <p>A crucial feature of continuation marks is that they allow one
      to attach marks to the most recent continuation frame without
      creating active non-tail calls.  This allows one to implement
      a <code>parameterize</code> form where the last expression in
      its body is in tail context when the <code>parameterize</code>
      form is in tail position.  Similarly, it becomes possible to
      implement <code>with-exception-handler</code> in a way so that
      its thunk is called in tail context if the call
      to <code>with-exception-handler</code> is in tail context.</p>
      The latter is not guaranteed by <cite>R<sup>6</sup>RS</cite>
      and <cite>R<sup>7</sup>RS</cite> (but should have according to
      the author of this SRFI).

    <p>In fact, with continuation marks, the concept of tail calls becomes
      operationally observable.</p>

    <h4>Continuations and Threads</h4>

    <p>The concept of threads and the semantics of multithreaded
      programs are deeply linked with the concepts that are involved
      in this specification.  For example, each thread possesses an
      initial continuation, containing a continuation prompt with a
      handler that has to be described.  For that, this specification
      contains a specification of a thread system mostly
      API-compatible with <cite>SRFI 18</cite> (and that exist
      alongside <cite>SRFI 18</cite>).  This helps making the
      existence of multiple threads, continuations, continuation
      prompts, and parameterizations mutually compatible.</p>

    <h4>Parameter Objects</h4>

    <p>Parameter objects are a tool to provide dynamically-scoped variables to
      the Scheme language in a clean way.  As a definition of parameter objects
      in terms of continuation marks is possible, and as an implementation in
      terms of them allows rich operations like capturing the current
      parameterization to later reinstall it, this SRFI provides both.</p>

    <p>Moreover, this specification makes a decision on the behavior of mutable
      parameter objects with respect to multiple threads.  If a parameter that
      is inherited by a newly created thread and has not been reparameterized
      is mutated by one of the threads, the mutation will also (eventually) be
      observed by the other thread.  This is a clear semantics because this is
      the same behavior as implemented by lexical variables.</p>

    <h4>Thread locals</h4>

    <p>Although they have been proposed for this application,
      parameter objects are unsuited to provide thread-local cells.  The
      main reason is that the current parameterization is part of the
      current continuation.  As the current continuation can be captured
      and reinstated in any thread, the parametrization cannot be a
      per-thread entity.</p>

    <p>Instead, this specification defines first-class thread locals
      akin to thread-specific storage in the <a href="c17"><cite>C
      programming language</cite></a> and to thread-specific data keys
      in <cite>POSIX</cite>.  In particular, the former can be efficiently
      implemented in terms of the latter.</p>

    <h4>Promises</h4>

    <p>A naive implementation of <code>delay</code> and <code>force</code> does
      not support iterative lazy algorithms as was observed, for example,
      in <a href="#van-tonder"><cite>SRFI 45</cite></a>.  That SRFI
      and <cite>R<sup>7</sup>RS</cite> solve the problem by providing another
      primitive, <code>delay-force</code> (called <code>lazy</code>
      in <cite>SRFI 45</cite>).  When continuation marks are available,
      however, such an irksome primitive is not needed;
      see <a href="#nieper2">SRFI 155</a>.  Consequently, this specification
      defines <dfn>promises</dfn> in a way that makes <code>delay-force</code>
      superfluous.</p>

    <p>Moreover, this specification amends <cite>R<sup>7</sup>RS</cite> in a
      way that defines the continuation in which the values of promises are
      forced in such a way that it has the same semantics as executing a
      thread.  This makes the overall system pleasantly coherent.  The sample
      implementation shows how everything can be implemented efficiently.</p>

    <p>Finally, promises as defined in this specification can deliver multiple
      values when forced, an extension too natural to ignore, and it is
      clearly specified what happens when an exception is raised during the
      forcing of a promise.</p>

    <h3>Relation to Other Standards</h3>

    <p>This specification is meant to be applicable to both
      standards, <cite>R<sup>6</sup>RS</cite>
      and <cite>R<sup>7</sup>RS</cite>.  The former standard allows
      the use of square brackets synonymous with parentheses in the
      syntax.  In its non-normative appendix C, advice is given in
      which places in the syntactic forms specified in the report they
      should be used.  In order to document in which places square
      brackets should be used in the syntactic forms described in this
      specification, this document uses them in the appropriate
      places.  When this specification is applied
      to <cite>R<sup>7</sup>RS</cite>, the square brackets should be
      read as parentheses.</p>

    <p>Some of the procedures and syntax defined in this specification
      have the same names as procedures and syntax
      of <cite>R<sup>6</sup>RS</cite>
      and <cite>R<sup>7</sup>RS</cite>.  In case a definition of such
      a procedure or syntax here does not conflict with the
      corresponding definition in a Scheme report, the procedure or
      syntax should be the same whether exported by the relevant
      standard libraries or one of the libraries described below.</p>

    <h3>Relation to Other SRFIs</h3>

    <p>This SRFI supersedes <a href="#kelsey2"><cite>SRFI
	  34</cite></a>, <cite>SRFI
	  39</cite>, <a href="#nieper1"><cite>SRFI
	  154</cite></a>, <cite>SRFI
	  155</cite>, and <a href="#nieper3"><cite>SRFI
	  157</cite></a>.</p>

    <p>The programming model defined by <cite>SRFI 18</cite> is
    extended.</p>

    <h3>Why this Proposal should be Incorporated as a Standard Feature
      in Scheme Implementations</h3>

    <ul>
      <li><p>In many if not most cases, <code>call/cc</code> (as
	  defined in previous standards and without continuation
	  prompts) is the wrong abstraction, a fact that has been well
	  known for a long time (see <a href="#kiselyov"><cite>An
	  argument against call/cc</cite></a>).  The
	  procedure <code>call/cc</code>, which captures undelimited
	  continuations, is usually advertised as the hammer that can
	  be used to implement all other control operations.  However,
	  this is not true.  <i>Delimited continuations</i>, on the
	  other hand, can be used to implement all other control
	  operations (see <a href="#filinski"><cite>Representing
	  Monads</cite></a>).  So it is actually delimited
	  continuations that are needed in practice.  Now everything
	  would be fine if delimited control operators could be
	  expressed in terms of <code>call/cc</code>.  This, however,
	  is not faithfully possible, especially not without space
	  leaks, as <code>call/cc</code> will capture parts of the
	  continuation that will never be reached after reinstating
	  (see <a href="#gasbichler"><cite>Final Shift for Call/cc:
	  Direct implementation of Shift and Reset</cite></a>).  Thus,
	  in hindsight Scheme should have always offered delimited
	  control operators instead of
	  <code>call/cc</code>.  Implementing this SRFI remedies that.</p></li>
      <li><p>By implementing this SRFI, even <code>call/cc</code>
	  becomes a delimited control operator thanks to the concept
	  of continuation prompts and the fact that one is available
	  at the start of each thread, including the primordial thread.</p></li>
      <li><p>In the literature, many sets of delimited control
	  operators can be found, with varying expressiveness.
	  Instead of primarily providing some or all of these, it makes
	  more sense to provide abstractions on top of which all these,
	  like <code>reset</code> and <code>shift</code>, can be built.
	  This SRFI offers these abstractions to Scheme
	  implementations.</p></li>
      <li><p>The continuation marks as defined in this SRFI can be
	  used, just to give an example, to write high-level debugging
	  tools and can more generally be used to inspect and attach
	  data to continuations.  Moreover, they make the concept of
	  tail calls operationally visible to Scheme.  Finally, they
	  enable some higher-order procedures to tail-call their
	  argument; a good example for this
	  is <code>with-exception-handler</code>, which should
	  tail-call its thunk.  Continuation marks enable one to write
	  such a version.</p></li>
      <li><p>Consequently, this SRFI provides versions of exception
	  handlers with improved tail-call guarantees.  The issue
	  is not academic as the right tail-call guarantees are
	  crucial for writing iterative algorithms in Scheme.</p></li>
      <li><p>Similarly, the <code>parameterize</code> form is defined
	  in this SRFI so that its body's last expression is in tail
	  context (if the whole form is).  This is semantically the
	  correct thing because parameters are substitutes for
	  implicit lexical parameters and so the usual tail-call
	  guarantees should apply as well.</p></li>
      <li><p>Using continuation marks, this SRFI makes
	  the <code>delay-force</code> form superfluous, and writing
	  iterative lazy algorithms becomes natural.  Moreover,
	  forcing promises is defined in a way to make it fully
	  similar to running threads.</p></li>
      <li><p>Finally, the initial continuation of threads is carefully
	  defined so that this SRFI offers clear semantics of
	  continuations and continuation prompts with respect to
	  multi-threaded programs.</p></li>
      <li><p>The interactions between the various features in this
	  proposal (continuation prompts, continuations, exceptions,
	  parameter objects, threads) have been carefully considered
	  and their semantics have been designed accordingly.
	  Incorporating these features as defined (or a suitable
	  subset of these) in a Scheme implementation guarantees
	  consistency and coherence.</p></li>
      <li><p>As the sample implementation shows, the features defined
	  in this SRFI are not hard to implement in a Scheme
	  implementation, which must already
	  implement <code>call/cc</code> anyway.</p></li>
    </ul>

    <h3>Implementation</h3>

    <p>The accompanying sample implementation does not implement the libraries
      defined in this specification, but it demonstrates how they can be as soon
      as a small set of easily implementable primitives are provided by the
      Scheme implementation.</p>

    <p>The sample implementation provides versions of all procedures and syntax
      described in this specification and allows playing with them.  A runnable
      test suite is also provided.</p>

    <p>The sample implementation is written in the Scheme dialect
      of <cite>R<sup>6</sup>RS</cite> because it is supposed to be run
      on <a href="#chezscheme"><cite>Chez Scheme</cite></a>, an implementation
      of that Scheme dialect.  However, the code should be easily adaptable to
      any other Scheme dialect.  In fact, the goal of the sample implementation
      is to enable Scheme implementers to add the procedures and syntax defined
      in this SRFI to their Scheme implementations with little effort.</p>

    <h2 id="specification">Specification</h2>

    <h3>Libraries</h3>

    <p>The syntax and procedures defined below are provided by
      sublibraries within <code>(srfi :226 control)</code>
      (see <a href="#van-horn"><cite>SRFI 97</cite></a>).</p>

    <p>The <code>(srfi :226)</code> and <code>(srfi :226
      control)</code> library is a composite of the sublibraries
      described in this specification.</p>

    <p>In an implementation of <cite>R<sup>7</sup>RS</cite>, the
      composite library is named <code>(srfi 226)</code> instead, and
      the sublibraries are sublibraries within <code>(srfi 226)</code>
      instead of <code>(srfi 226 :control)</code>.  Moreover, the
      library name parts are singularized.</p>

    <p>It is expected that a future Scheme standard building on the
      procedures and syntax defined in this document will choose a
      different packaging into libraries, possibly fewer ones.</p>

    <h3>Entry format</h3>

    <p>The following naming conventions imply type restrictions:</p>

    <dl>
      <dt><code><var>obj</var></code>, <code><var>key</var></code></dt>
      <dd>any objects</dd>
      <dt><code><var>name</var></code></dt>
      <dd>symbol</dd>
      <dt><code><var>list</var></code></dt>
      <dd>list</dd>
      <dt><code><var>thunk</var></code>, <code><var>pre-thunk</var></code>, <code><var>post-thunk</var></code></dt>
      <dd>zero-argument procedures</dd>
      <dt><code><var>cont</var></code></dt>
      <dd>continuation</dd>
      <dt><code><var>prompt-tag</var></code></dt>
      <dd>prompt tag</dd>
      <dt><code><var>mark-set</var></code></dt>
      <dd>continuation mark set or <code>#f</code></dd>
      <dt><code><var>parameterization</var></code></dt>
      <dd>parameterization</dd>
      <dt><code><var>promise</var></code></dt>
      <dd>promise</dd>
      <dt><code><var>handler</var></code></dt>
      <dd>procedure or <code>#f</code></dd>
      <dt><code><var>k</var></code></dt>
      <dd>undelimited continuation</dd>
      <dt><code><var>tl</var></code></dt>
      <dd>thread local</dd>
      <dt><code><var>timeout</var></code></dt>
      <dd>real number or <code>#f</code></dd>
      <dt><code><var>thread</var></code></dt>
      <dd>thread</dd>
      <dt><code><var>owner-thread</var></code></dt>
      <dd>thread or <code>#f</code></dd>
      <dt><code><var>mutex</var></code></dt>
      <dd>mutex</dd>
      <dt><code><var>condition-variable</var></code></dt>
      <dd>condition variable</dd>
    </dl>

    <h3>Iterators</h3>

    <p>An <dfn>iterator</dfn> for a list in the sense of this
      specification is a zero-argument procedure that returns two
      values on each invocation.  An iterator for the empty list
      returns <code>#f</code> and an iterator for the empty list.  An
      iterator for a non-empty list returns the head of the list and
      an iterator for its tail.  Note that this iterator protocol is
      unsuitable for lists that potentially
      contain <code>#f</code>.</p>

    <h3>Safety</h3>

    <p>The libraries described by this SRFI are <i>safe libraries</i>
      in the sense of <cite>R<sup>6</sup>RS</cite>.  In particular, in
      the presence of multiple threads, concurrent reading and writing
      to a location must not threaten system integrity in ways that
      might result in execution that is inconsistent with the
      semantics described in the Scheme reports and in this document.
      All modifications to single locations in the store must appear
      atomic to each thread.</p>

    <h3>Continuation Prompts</h3>

    <p>This section describes the <code>(srfi :226 control prompts)</code> library.</p>

    <h4>Conditions</h4>

    <p><i>Note:</i> If this SRFI is implemented in a system that does not
      support the condition system of <cite>R6RS</cite>, the respective parts
      of this specification should be applied <i>mutatis mutandis</i>.  We
      follow the presentation style of <cite>R6RS</cite> for the condition
      types defined in this and the other libraries.</p>

    <dl class="entries">
      <dt class="entry"><code>&amp;continuation</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-continuation-violation <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-violation? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-violation-prompt-tag <var>condition</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;continuation &amp;violation
  make-continuation-violation continuation-violation?
  (prompt-tag continuation-violation-prompt-tag))</pre>
	<p>This condition type describes violations that occurred
	  during non-local control
	  operations.  <code><var>Prompt-tag</var></code> should be
	  the tag of the delimiting prompt.</p>
      </dd>
    </dl>

    <h4>Prompt Tags</h4>

    <p>Continuation prompts are tagged with <dfn>prompt tags</dfn>,
      which are opaque values.  A distinguished prompt tag is
      the <dfn>default prompt tag</dfn>.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-prompt-tag)</code></dt>
      <dt class="procedure"><code>(make-continuation-prompt-tag <var>name</var>)</code></dt>
      <dd>
	<p>Returns a prompt tag that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-prompt-tag</code>
	  or <code>default-continuation-prompt-tag</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the prompt tag.
	</p>
      </dd>

      <dt class="procedure"><code>(default-continuation-prompt-tag)</code></dt>
      <dd>
	<p>Returns the default prompt tag.</p>
      </dd>

      <dt class="procedure"><code>(continuation-prompt-tag? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  prompt tag, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <pre class="example">(continuation-prompt-tag? (default-continuation-prompt-tag))<span class="result">#t</span>
(eq? (default-continuation-prompt-tag) (default-continuation-prompt-tag))<span class="result">#t</span>
(continuation-prompt-tag? (make-continuation-prompt-tag))<span class="result">#t</span>
(equal? (make-continuation-prompt-tag) (default-continuation-prompt-tag))<span class="result">#f</span>
(equal? (make-continuation-prompt-tag) (make-continuation-prompt-tag))<span class="result">#f</span></pre>

    <h4>Continuation Prompts</h4>

    <p>We identify a <dfn>continuation</dfn> with a sequence of active
      procedure calls, beginning with the most recent call.  A
      continuation can be uniquely partitioned into
      <dfn>continuation frames</dfn>, which are maximal subsequences
      of active procedure calls containing an arbitrary number of
      active tail calls followed by at most one active non-tail call.</p>

    <p>A <dfn>continuation prompt</dfn> is a type of continuation
      frame such that when values are delivered to a continuation
      extended by such a continuation frame, the values are
      effectively delivered to the non-extended continuation.
      Moreover, each continuation prompt is tagged with a
      prompt tag and records a <dfn>prompt handler</dfn>, which
      is a procedure.</p>

    <p>A continuation prompt with a given prompt tag
      is <dfn>available</dfn> in a continuation if a continuation
      prompt with the given tag is contained in the continuation's
      sequence of continuation frames.</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-continuation-prompt <var>thunk</var>)</code></dt>
      <dt class="procedure"><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var> <var>handler</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	  defaults to the default prompt tag,
	  and <code><var>handler</var></code> defaults
	  to <code>#f</code>.</p>

	<p>The <code>call-with-continuation-prompt</code> procedure
	  instates a continuation prompt that is tagged
	  with <code><var>prompt-tag</var></code> and
	  records <code><var>handler</var></code> in the continuation
	  to its call.  Finally, <code><var>thunk</var></code> is
	  called with no arguments in the resulting continuation.</p>

	<p>If <code><var>handler</var></code> is <code>#f</code>, the
	  default handler is used instead.  The default handler is a
	  procedure that takes a single
	  argument <code><var>thunk</var></code>.  When the default
	  handler is called, it reinstates the continuation prompt and
	  calls <code><var>thunk</var></code> with no arguments in the
	  resulting continuation.</p>

	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
      </dd>

      <dt class="procedure"><code>(abort-current-continuation <var>prompt-tag</var> <var>obj</var>
      &hellip;)</code></dt>
      <dd>
	<p>The <code>abort-current-continuation</code> procedure
	  aborts all active procedure calls in the current
	  continuation until a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is aborted and
	  replaces them with a call to the handler recorded with the
	  prompt tag with the
	  arguments <code><var>obj</var></code>s.</p>
	<p>
	  When a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the continuation processed
	  by <code>abort-current-continuation</code>, an exception
	  with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p><i>Note:</i> Even if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  current continuation
	  when <code>abort-current-continuation</code> is called, due
	  to the presence of <code>dynamic-wind</code> winders (see
	  below) it can still happen during the aborting process that
	  it becomes no longer available.
	</p>
      </dd>
    </dl>

    <pre class="example">(let ([tag (make-continuation-prompt-tag)])
  (call-with-continuation-prompt
    (lambda ()
      (+ 1
         (abort-current-continuation tag 'foo 'bar)
         2))
    tag
    list))<span class="result">(foo bar)</span></pre>

   <p>The following example demonstrates that the prompt is
      reinstalled by the default handler.</p>

    <pre class="example">(let ([tag (make-continuation-prompt-tag)])
  (call-with-continuation-prompt
   (lambda ()
     (abort-current-continuation tag
       (lambda ()
         (abort-current-continuation tag
           (lambda ()
             27)))))
   tag
   #f))<span class="result">27</span></pre>

    <h3>Continuations</h3>

    <p>This section describes the <code>(srfi :226 control
	continuations)</code> library.  This library, in addition to the
      procedures described here, also exports the condition types
      described in the previous section on continuation prompts.</p>

    <p>Each <dfn>continuation (procedure)</dfn> is a procedure.</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-non-composable-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(call-with-non-composable-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-current-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call/cc <var>proc</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The procedure <code>call-with-non-composable-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a continuation prompt
	  tagged with <code><var>prompt-tag</var></code> as a
	  continuation (“escape”) procedure and passes it as an
	  argument to <code><var>proc</var></code>.  The continuation
	  procedure is a Scheme procedure such that, if it is later called,
	  aborts all active procedure calls in the then-current
	  continuation up to but not including a continuation prompt
	  with <code><var>prompt-tag</var></code> or up to but not
	  including an active procedure call shared by the current and
	  captured continuations, whichever comes first.  Finally, the
	  active procedure calls in the unshared portion of the
	  captured continuation are reinstated and the arguments
	  supplied to the call to the continuation procedure become
	  the result values for the new current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-non-composable-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation when the continuation procedure is called, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>The identifier <code>call/cc</code> is an alias
	for <code>call-with-current-continuation</code>, which does
	not take a <code><var>prompt-tag</var></code> argument.</p>
	<p><i>Note:</i> As a continuation prompt tagged with the
	  default prompt tag is available in the initial continuation
	  of each thread, including the primordial thread,
	  the <code>call-with-non-composable-continuation</code> defined here is
	  a conservative extension of
	  the <code>call-with-non-composable-continuation</code> of earlier
	  Scheme reports.</p>
      </dd>
    </dl>

    <p>The following example shows how continuation prompts delimit
      the captured continuation and the continuation to be replaced.</p>

    <pre class="example">(let ([tag (make-continuation-prompt-tag)])
  (* 2
   (call-with-continuation-prompt
    (lambda ()
      (* 3
         (call-with-non-composable-continuation
          (lambda (k)
            (* 5
               (call-with-continuation-prompt
                (lambda ()
                  (* 7 (k 11)))
                tag)))
         tag)))
    tag)))<span class="result">990</span></pre>

    <p>When the continuation is captured in this example, all active
      procedure calls up to nearest (dynamically) enclosing prompt
      (tagged with the value of <code>tag</code>) are captured.
      Effectively, multiplication by <code>3</code> is captured.  When
      the continuation is invoked in this example, its active
      procedure calls are reinstated after the current continuation
      has been cut back to the nearest enclosing prompt at the point
      of invoking the captured continuation.  Effectively, the
      multiplication by <code>7</code> is removed and replaced by the
      captured multiplication by <code>3</code>.  In effect, this
      yields the value of <code>(* 2 (* 3 (* 5 (* 3 11))))</code>,
      which is <code>990</code>.</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The
	  procedure <code>call-with-composable-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a continuation prompt
	  tagged with <code><var>prompt-tag</var></code> as a
	  continuation (“escape”) procedure and passes it as an
	  argument to <code><var>proc</var></code>.  The continuation
	  procedure is a Scheme procedure such that, if it is later called,
	  the active procedure calls in the captured continuation are
	  reinstated and the arguments supplied to the call to the
	  continuation procedure become the result values for the new
	  current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-composable-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p><i>Note:</i> The difference between the continuation
	  procedure returned
	  by <code>call-with-non-composable-continuation</code>
	  and <code>call-with-composable-continuation</code> is that
	  the former removes portions of the then-current
	  continuation, while the latter does not.  The former
	  continuation procedures are called <dfn>non-composable
	  continuations</dfn>, while the latter are
	  called <dfn>composable continuations</dfn>.  The latter
	  usually return values to the continuation in which they are
	  called, while the former never do.</p>
      </dd>
    </dl>

    <p>The following example is similar to the previous one except
    that the call to <code>call-with-non-composable-continuation</code> is
    replaced with a call
    to <code>call-with-composable-continuation</code>.  Accordingly,
    invoking the captured continuation does not remove any active
    procedure calls and so the result of the second example
    is <code>7</code> times the value of the first.</p>

    <pre class="example">(let ([tag (make-continuation-prompt-tag)])
  (* 2
   (call-with-continuation-prompt
    (lambda ()
      (* 3
         (call-with-composable-continuation
          (lambda (k)
            (* 5
               (call-with-continuation-prompt
                (lambda ()
                  (* 7 (k 11)))
                tag)))
         tag)))
    tag)))<span class="result">6930</span></pre>

    <p>This concept of composable continuations together with the
      facility to install and abort to continuation prompts is rich
      enough to support the known delimited control operators.  For
      example, the control operators
      <code>reset</code> and <code>shift</code>
      from <a href="#danvy"><cite>Abstracting Control</cite></a> can be implemented as
      follows:</p>

    <pre class="example">(define-syntax reset
  (syntax-rules ()
    [(reset e1 e2 ...)
     (call-with-continuation-prompt
      (lambda ()
        e1 e2 ...))]))

(define-syntax shift
  (syntax-rules ()
    [(shift k e1 e2 ...)
     (call-with-composable-continuation
       (lambda (k)
         (abort-current-continuation (default-continuation-prompt-tag)
           (lambda ()
             e1 e2 ...))))]))

(+ 1 (reset 3))<span class="result"> 4</span>
(+ 1 (reset (* 2 (shift k 4))))<span class="result"> 5</span>
(+ 1 (reset (* 2 (shift k (k 4)))))<span class="result"> 9</span>
(+ 1 (reset (* 2 (shift k (k (k 4))))))<span class="result">17</span>
(+ 1 (reset (* 2 (shift k1 (* 3 (shift k2 (k1 (k2 4))))))))<span class="result">25</span></pre>

    <p>Another possible pair of control operators is made
    by <code>prompt</code> and <code>control</code>.  The difference
    with <code>reset</code>/<code>shift</code> is
      that <code>control</code> does not reinstate the prompt.</p>

    <pre class="example">(define-syntax prompt
  (syntax-rules ()
    [(prompt e1 e2 ...)
     (call-with-continuation-prompt
      (lambda ()
	e1 e2 ...)
      (default-continuation-prompt-tag)
      (lambda (thunk)
	(thunk)))]))

(define-syntax control
  (syntax-rules ()
    [(control k e1 e2 ...)
     (call-with-composable-continuation
      (lambda (k)
	(abort-current-continuation (default-continuation-prompt-tag)
	  (lambda ()
	    e1 e2 ...))))]))

(prompt (+ 2 (control k (k 5))))<span class="result"> 7</span>
(prompt (+ 2 (control k 5)))<span class="result"> 5</span>
(prompt (+ 5 (prompt (+ 2 (control k1 (+ 1 (control k2 (k2 6))))))))<span class="result">12</span>
(prompt (+ 5 (prompt (+ 2 (control k1 (+ 1 (control k2 (k1 6))))))))<span class="result"> 8</span>
(prompt
  (+ 12 (prompt (+ 5 (prompt (+ 2 (control k1 (control k2 (control k3 (k3 6))))))))))
<span class="result">18</span>
</pre>

    <dl class="entries">
      <dt class="procedure"><code>(continuation? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  continuation procedure, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <pre class="example">(continuation? (call/cc values))<span class="result">#t</span>
(continuation? (call-with-composable-continuation values))<span class="result">#t</span></pre>

    <dl class="entries">
      <dt class="procedure"><code>(call-in-continuation <var>cont</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>
	  Aborts and reinstates active procedure calls as if the
	  continuation procedure <code><var>cont</var></code> were
	  applied, but instead of delivering values to then-current
	  continuation, the procedure <code><var>thunk</var></code> is
	  called with no arguments in this continuation.</p>
      </dd>
    </dl>

    <p>The <code>call-in-continuation</code> procedure can be used to implement
      the <code>guard</code> syntax concisely:</p>

    <pre class="example">(define-syntax/who guard
  (lambda (stx)
    (syntax-case stx ()
      [(_ (id c1 c2 ...) e1 e2 ...)
       (identifier? #'id)
       #`(call-with-current-continuation
	  (lambda (guard-k)
	    (with-exception-handler
		(lambda (c)
		  (call-with-current-continuation
		   (lambda (handler-k)
		     (call-in-continuation guard-k
		       (lambda ()
			 (let ([id c])
			   #,(let f ([c1 #'c1] [c2* #'(c2 ...)])
			       (syntax-case c2* ()
				 [()
				  (with-syntax
				      ([rest
					#'(call-in-continuation handler-k
					    (lambda ()
					      (raise-continuable c)))])
				    (syntax-case c1 (else =>)
				      [(else e1 e2 ...)
				       #'(begin e1 e2 ...)]
				      [(e0) #'e0]
				      [(e0 => e1)
				       #'(let ([t e0]) (if t (e1 t) rest))]
				      [(e0 e1 e2 ...)
				       #'(if e0
					     (begin e1 e2 ...)
					     rest)]))]
				 [(c2 c3 ...)
				  (with-syntax ([rest (f #'c2 #'(c3 ...))])
				    (syntax-case c1 (=>)
				      [(e0) #'(let ([t e0]) (if t t rest))]
				      [(e0 => e1)
				       #'(let ([t e0]) (if t (e1 t) rest))]
				      [(e0 e1 e2 ...)
				       #'(if e0
					     (begin e1 e2 ...)
					     rest)]))]))))))))
		(lambda ()
		  e1 e2 ...))))]
      [_
       (syntax-violation who "invalid syntax" stx)])))</pre>

    <p>Invoking a continuation <code>k</code> on
      values <code><var>obj</var></code> &hellip; can be defined
      in terms of <code>call-in-continuation</code>:</p>

    <pre class="example">(let ([<var>tmp</var> <var>obj</var>] &hellip;)
  (call-in-continuation k (lambda () (values <var>tmp</var> &hellip;))))</pre>

    <p>On the other hand, it is not possible to
      define <code>call-in-continuation</code> in terms of invoking a
      continuation, so the former is the more primitive notion.</p>

    <p><i>Remark:</i> That a primitive like <code>call-in-continuation</code>
      is needed, was already noted in <a href="#feeley3"><cite>A better API for
      first-class continuations</cite></a>.  In that paper, it is
      called <code>continuation-graft</code>.  (The two accompanying
      procedures <code>continuation-capture</code>
      and <code>continuation-return</code> in that paper are
      just <code>call/cc</code> and <code>apply</code> in the context of this
      SRFI, which treats continuations as procedures for compatiblity
      reasons.)</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-continuation-barrier <var>thunk</var>)</code></dt>
      <dd>
	<p>The <code>call-with-continuation-barrier</code> procedure
	  instates an otherwise inaccessible continuation prompt in
	  the current continuation and marks it as
	  a <dfn>continuation barrier</dfn>.
	  Finally, <code><var>thunk</var></code> is called with no
	  arguments in the resulting continuation.</p>
	<p>When applying a non-composable continuation would reinstate
	  a continuation barrier, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>If a continuation barrier is captured during a call
	to <code>call-with-composable-continuation</code>, an
	exception with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p>This extends the semantics
	  of <code>call-with-non-composable-continuation</code>
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
	<p><i>Note:</i> As calling a composable continuation never
	  aborts active procedure calls, a continuation barrier would
	  be reinstated if and only if the captured continuation
	  included a continuation barrier.</p>
      </dd></dl>

      <p>A continuation barrier prevents jumps into more deeply nested
      active procedure calls:</p>

      <pre class="example">((call-with-continuation-barrier
  (lambda ()
    (call/cc values))))<span class="result">&amp;continuation-violation <i>exception</i></span></pre>

      <p>On the other hand, escaping jumps are not prohibited:</p>

      <pre class="example">(call/cc
  (lambda (k)
    (call-with-continuation-barrier
      (lambda ()
        (k 'ok)))))<span class="result">ok</span></pre>

      <dl class="entries">
      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var> <var>cont</var>)</code></dt>
      <dd>
	<p>The first form is operationally equivalent to
	  <code>(continuation-prompt-available? <var>prompt-tag</var> (call/cc values))</code>.</p>
	<p>Returns <code>#t</code> if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  continuation packaged in <code><var>cont</var></code> or
	  if <code><var>cont</var></code> is a non-composable
	  continuation delimited
	  by <code><var>prompt-tag</var></code>, and <code>#f</code>
	  otherwise.</p>
      </dd></dl>

      <pre class="example">(define tag (make-continuation-prompt-tag))
(call-with-continuation-prompt-tag
  (lambda ()
    (continuation-prompt-tag-available? tag
      (call-with-non-composable-continuation values))))<span class="result">#t</span>
(call-with-continuation-prompt-tag
  (lambda ()
    (continuation-prompt-tag-available? tag
      (call-with-non-composable-continuation values tag))))<span class="result">#t</span>
(call-with-continuation-prompt-tag
  (lambda ()
    (continuation-prompt-tag-available? tag
      (call-with-composable-continuation values tag))))<span class="result">#f</span></pre>
      <dl class="entries">
      <dt class="procedure"><code>(dynamic-wind <var>pre-thunk</var> <var>thunk</var> <var>post-thunk</var>)</code></dt>
      <dd>
	<p>The <code>dynamic-wind</code> procedure
	  calls <code><var>pre-thunk</var></code> with no arguments in
	  a continuation that calls <code><var>thunk</var></code> with
	  no arguments in a continuation that
	  calls <code><var>post-thunk</var></code> in a continuation
	  with no arguments that finally delivers the results of the
	  call to <code><var>thunk</var></code> to the continuation of
	  the call to <code>dynamic-wind</code>.</p>
	<p>Moreover, when the active call
	  to <code><var>thunk</var></code> is aborted (either due to a
	  prompt abort or a continuation procedure
	  invocation), <code><var>post-thunk</var></code> is called
	  with no arguments, and when the active call
	  to <code><var>thunk</var></code> is reinstated (due to a
	  continuation procedure
	  invocation), <code><var>pre-thunk</var></code> is called
	    with no arguments.</p>
	<p>Each call to <code><var>pre-thunk</var></code>
	  and <code><var>post-thunk</var></code> belongs to the dynamic
	  extent of the original call to <code>dynamic-wind</code>.</p>
	<p><i>Note:</i> When a call
	  to <code><var>pre-thunk</var></code>
	  or <code><var>post-thunk</var></code> returns during a
	  prompt abort or a continuation procedure invocation, the
	  sequence of active procedure calls that still have to be
	  aborted and the sequence of active procedure calls that
	  still have to be reinstated may have changed due to the
	  application of composable continuations captured
	  in <code><var>pre-thunk</var></code>
	  or <code><var>post-thunks</var></code>.
	<p>This extends the semantics
	  of <code>abort-current-continuation</code>, <code>call-with-non-composable-continuation</code>,
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
      </dd>
    </dl>

    <p>The following example comes form <cite>R<sup>6</sup>RS</cite>
      and demonstrates jumping out of the post-thunk.</p>

    <pre class="example">(let ([n 0])
  (call/cc
    (lambda (k)
      (dynamic-wind
          values
          (lambda ()
            (dynamic-wind
                values
                (lambda ()
                  (set! n (+ n 1))
                  (k))
                (lambda ()
                  (set! n (+ n 2))
                  (k))))
         (lambda ()
           (set! n (+ n 4))))))
  n)<span class="result">7</span></pre>

    <h3>Continuation Marks</h3>

    <p>This section describes the <code>(srfi :226 control
	continuation-marks)</code> library.  This library, in addition
	to the procedures described here, also exports the condition
	types described in the section on continuation prompts.</p>

    <h4>Continuation Marks</h4>

    <p>Continuation frames can be annotated with <dfn>continuation
	marks</dfn>.  Each continuation mark maps a key, which can be
	an arbitrary object, to a value, which can also be an
	arbitrary object.  If a continuation frame is annotated with a
	continuation mark for a key for which the continuation frame
	has already been annotated with a mark, the most recent
	annotation prevails.</p>

    <p><i>Remark:</i> In <cite>A better API for first-class
      continuations</cite>, the idea of a portable debugger using a procedure
      named <code>continuation-next</code> to walk up a continuation was
      presented.  With continuation marks this can be easily achieved when
      frames are explicitly marked.  The advantage of an explicit marking is
      that the debugger can then be instructed to automatically skip over
      frames installed by standard library procedures, for example.  A Scheme
      system could offer a debug mode, in which every frame is automatically
      marked in a specific way that is understood by the debugger.
    </p>

    <dl class="entries">
      <dt class="syntax"><code>(with-continuation-mark <span class="token">key-expr</span> <span class="token">val-expr</span> <span class="token">expression</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Key-expr</span></code>, <code><span class="token">val-expr</span></code>,
	  and <code><span class="token">expression</span></code> are expressions.</p>
	<p><i>Semantics:</i>
	  <code>Key-expr</code> and <code>val-expr</code> are
	  evaluated in an unspecified order to obtain a key and a
	  value, respectively. The most recent continuation frame
	  in the continuation of
	  the <code>with-continuation-mark</code> expression is then
	  dynamically annotated with a continuation mark mapping the
	  key to the value, and <code>expression</code> is evaluated
	  in the continuation of
	  the <code>with-continuation-mark</code> expression.</p>
	<p>If a <code>with-continuation-mark</code> expression is in
	tail context, <code>expression</code> is in tail context as
	  well.</p>
        <p><i>Note:</i> That <code>with-continuation-mark</code> is a
          special form and not modeled as a procedure calling a thunk
          goes back to the paper <a href="#clements"><cite>Modeling an
          Algebraic Stepper</cite></a>, which introduced continuation
          marks.  In fact, it makes optimization for a Scheme compiler
          easier, and <code>with-continuation-mark</code> needs to be
          efficient given its typical use cases.</p>
      </dd>

      <dt class="syntax"><code>(with-continuation-marks ([<span class="token">key-expr</span> <span class="token">val-expr</span>] &hellip;) <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code>The <span class="token">key-expr</span></code>s and
	  the <code><span class="token">val-expr</span></code>s are
	  be expressions, and <code><span class="token">body</span></code> is
	  be a body.</p>
	<p><i>Semantics:</i> The <code>key-expr</code>s and
	  the <code>val-expr</code>s are evaluated in an unspecified
	  order to obtain a list of keys and a list of corresponding
	  values, respectively. The most recent continuation frame in
	  the continuation of the <code>with-continuation-marks</code>
	  expression is then dynamically annotated with a continuation
	  mark mapping the keys to the values,
	  and <code>body</code> is evaluated in the continuation
	  of the <code>with-continuation-marks</code> expression.</p>
	<p>It is unspecified which value prevails if two of the keys are the
	  same.</p>
	<p>If a <code>with-continuation-marks</code> expression is in
	  tail context, the last expression of <code>body</code> is in
	  tail context as well.</p>
      </dd>

      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If the most recent continuation frame in the continuation
	of the call
	to <code>call-with-immediate-continuation-mark</code> is
	annotated with a continuation mark mapping <var>key</var> to a
	value, <var>proc</var> is applied to the value, and
	to <var>obj</var> otherwise.</p>
	<p>If a call
	  to <code>call-with-immediate-continuation-mark</code> occurs
	  in a tail context, the call to <code><var>proc</var></code>
	  is also in a tail context.</p>
      </dd>
    </dl>
    <pre class="example">(with-continuation-mark 'key 'mark
  (call-with-immediate-continuation-mark 'key values))<span class="result">mark</span>

(let ([tag (make-continuation-prompt-tag)])
  (with-continuation-mark 'key 'mark
    (call-with-continuation-prompt
      (lambda ()
        (call-with-immediate-continuation-mark 'key values 'default))
      tag)))<span class="result">default</span></pre>

    <p>In the second example, we installed a continuation prompt with
      some unrelated tag to make sure that the call
      to <code>call-with-immediate-continuation-mark</code> is not in
      tail context with respect to
      the <code>with-continuation-mark</code> expression.</p>

    <dl class="entries">
      <dt class="procedure"><code>(continuation-marks <var>cont</var>)</code></dt>
      <dt class="procedure"><code>(continuation-marks <var>cont</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a continuation mark set capturing the continuation
	  marks of the continuation frames in the
	  continuation <code><var>cont</var></code> up to the
	  continuation prompt <code>prompt-tag</code>.</p>
	<p>If no continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available
	  in <code><var>cont</var></code> and the
	  continuation <code><var>cont</var></code> is not delimited
	  by <code><var>prompt-tag</var></code>, an exception with
	  condition type <code>&amp;continuation</code> is raised.</p>
      </dd>

      <dt class="procedure"><code>(current-continuation-marks)</code></dt>
      <dt class="procedure"><code>(current-continuation-marks <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Operationally equivalent to <code>(continuation-marks
	(call/cc
	values <var>prompt-tag</var>) <var>prompt-tag</var>)</code>.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	continuation mark set, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <pre class="example">(continuation-mark-set? (current-continuation-marks))<span class="result">#t</span></pre>

    <dl class="entries">
      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a newly allocated list containing the values of the
	  continuation marks for <code><var>key</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding continuation frames were separated by a
	  continuation prompt
	  tagged <code><var>prompt-tag</var></code>, if at all.  The
	  list elements correspond to the continuation frames that
	  contained a continuation mark
	  for <code><var>key</var></code>, with the most recent
	  continuation frame coming first.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a newly allocated list containing newly allocated
	  vectors.  The vectors contain the values of the continuation
	  marks for the keys in <code><var>list</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding continuation frames were separated by a
	  continuation prompts
	  tagged <code><var>prompt-tag</var></code>, if at all, as
	  follows: Each vector contains the continuation marks of a
	  single continuation frame for the keys contained
	  in <code><var>list</var></code>.  If such a continuation
	  frame has no mark for some key
	  in <code><var>list</var></code>, the
	  values <code><var>obj</var></code> is used.  The vectors in
	  the newly allocated list correspond to the continuation
	  frames that contain a continuation mark for at least one key
	  in <code><var>list</var></code> with the most recent
	  continuation frames coming first.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>
    </dl>

    <pre class="example">(define tag (make-continuation-prompt-tag))
(define key (make-continuation-mark-key))
(define key1 (make-continuation-mark-key))
(define key2 (make-continuation-mark-key))

(with-continuation-mark key 'mark1
  (with-continuation-mark key 'mark2
    (call-with-continuation-prompt
      (lambda ()
        (with-continuation-mark key 'mark3
          (continuation-mark-set->list #f key))))))<span class="result">(mark3 mark2)</span>

(with-continuation-mark key1 'mark1
  (with-continuation-mark key2 'mark2
    (call-with-continuation-prompt
     (lambda ()
       (with-continuation-mark key1 'mark3
         (continuation-mark-set->list* #f (list key1 key2) 'default)))
     tag))<span class="result">(#(mark3 default) #(mark1 mark2))</span></pre>

    <dl class="entries">
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag)</var></code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns an iterator for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments.</p>
	<p><i>Note:</i> Some recent SRFIs that have been included into
	  early editions of <a href="#r7rs"><cite>R<sup>7</sup>RS
	  Large</cite></a> or are to be included in its forthcoming
	  editions feature the use of generators (see <a href="">SRFI
	  158</a>) to process lists (or objects of other sequence
	  types).  As generators are fundamentally non-pure, we
	  believe that their use should be limited in otherwise
	  functional code.  The iterator concept used here, on the
	  other hand, is fully functional.  It does have to be
	  modified for lists that may potentially
	  contain <code>#f</code>, which cannot happen here.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>
    </dl>

    <p>A correct but possibly inefficient implementation
    of <code>continuation-mark-set-&gt;iterator</code> is given as
    follows:</p>

    <pre class="example">(define continuation-mark-set-&gt;iterator
  (lambda arg*
    (let f ([ls (apply continuation-mark-set-&gt;list arg*)])
      (lambda ()
        (if (null? ls)
          (values #f (f '()))
          (values (car ls) (f (cdr ls))))))))</pre>

    <dl class="entries">
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns the first element for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments, or <code>obj</code> if
	  the result would be the empty list.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>
    </dl>

    <pre class="example">(let ([tag (make-continuation-prompt-tag)]
      [key (make-continuation-mark-key)])
  (with-continuation-mark key 'mark1
    (call-with-continuation-prompt
     (lambda ()
       (with-continuation-mark key 'mark2
         (continuation-mark-set-first #f key)))
     tag)))<span class="result">mark2</span></pre>

    <h4>Mark Keys</h4>

    <p><dfn>Mark keys</dfn> can be used as opaque keys for
    continuation marks.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-mark-key)</code></dt>
      <dt class="procedure"><code>(make-continuation-mark-key <var>name</var>)</code></dt>
      <dd>
	<p>Returns a mark key that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-mark-key</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the mark key.
	</p>
      </dd>
      <dt class="procedure"><code>(continuation-mark-key? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	mark key, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <pre class="example">(continuation-mark-key? (make-continuation-mark-key))<span class="result">#t</span>
(equal? (make-continuation-mark-key) (make-continuation-mark-key))<span class="result">#f</span></pre>

    <h3>Parameter Objects</h3>

    <p>This section describes the <code>(srfi :226 control
	parameters)</code> library.</p>

    <p>Each <dfn>parameter object</dfn> is a procedure.</p>

    <p>A <dfn>parameterization</dfn> is an opaque mapping of parameter objects
    to cells that hold a value.</p>

    <p>Conceptually, each continuation contains at least one otherwise
      inaccessible parameterization continuation mark, whose value is a
      parameterization.  The <dfn>parameterization of a continuation</dfn> is
      the value of the most recent parameterization continuation mark in the
      continuation.  The parameterization of the current continuation is
      the <dfn>current parameterization</dfn>.

    <p>The parameterization of the initial continuation of a top-level program
      maps each current and future parameter object to a cell holding its
      initial value.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-parameter <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(make-parameter <var>obj</var> <var>proc</var>)</code></dt>
      <dd>
	<p>Invokes <code><var>proc</var></code>
	  on <code><var>obj</var></code> in the dynamic environment of
	  the call to <code>make-parameter</code>to obtain a value and
	  returns a newly allocated parameter object, which is a
	  procedure accepting zero or one argument and
	  whose <dfn>initial value</dfn> is the value and
	  whose <dfn>conversion procedure</dfn>
	  is <code><var>proc</var></code>.</p>
	<p>
	  When a parameter object is invoked with zero arguments, the content
	  of the cell of the parameter object in the parameterization of the
	  invocation is returned.
	</p>
	<p>When a parameter object is invoked with one argument, its
	  conversion function is applied to it in the dynamic
	  environment of the call to the parameter object to obtain a
	  new value.  The previous value contained in the cell of the
	  parameter object in the parameterization of the invocation
	  is then replaced with the new value.  The result of the
	  invocation is unspecified.</p>
      </dd>

      <dt class="syntax"><code>(parameterize ([<span class="token">param-expr</span> <span class="token">expression</span>] &hellip;) <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  The <code><span class="token">param-expr</span></code>s and
	  the <code><span class="token">expression</span></code>s are
	  expressions, and <code><span class="token">body</span></code> is
	  a body.</p>
	<p><i>Semantics:</i> Evaluates
	  the <code><span class="token">param-expr</span></code>s
	  and <code><span class="token">expressions</span></code> in
	  an arbitrary order to obtain parameter objects and arbitrary
	  objects, respectively.  An assertion violation is raised if
	  one of the obtained parameter objects is not actually a
	  parameter object.  The objects are then mapped to respective
	  values by invoking the conversion procedures of the
	  corresponding parameter objects in the dynamic environment
	  of the <code>parameterize</code> expression on them.  For
	  each parameter object, a newly allocated cell is then
	  constructed that holds the obtained corresponding value.  A
	  new parameterization that differs from the parameterization
	  of the continuation of the <code>parameterize</code>
	  expression in mapping the obtained parameter objects to the
	  respectively newly allocated cells is then constructed.
	  Finally, the most recent continuation frame in the
	  continuation of the <code>parameterize</code> expression is
	  annotated with a parameterization continuation mark whose
	  value is the new parameterization and
	  the <code><span class="token">body</span></code> is
	  evaluated in this continuation.</p>
	<p>It is unspecified which value prevails if two of the
	  parameter objects are the same.</p>
	<p>If a <code>parameterize</code> expression is in tail
	  context, the last expression
	  in <code><span class="token">body</span></code> is in tail
	  context as well.</p>
      </dd>
      <dt class="procedure"><code>(current-parameterization)</code></dt>
      <dd>
	<p>Returns the current parameterization.</p>
      </dd>
      <dt class="procedure"><code>(parameterization? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	parameterization, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="procedure"><code>(call-with-parameterization <var>parameterization</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>Annotates the most recent continuation frame in the current
	  continuation with a parameterization continuation mark whose
	  value is <code><var>parameterization</var></code>, and
	  invokes <code><var>proc</var></code> in this continuation.
	</p>
	<p>In particular, if a call
	to <code>call-with-current-parameterization</code> occurs in a tail
	context. the call to <code><var>proc</var></code> is also in a tail
	context.</p>
      </dd>
    </dl>

    <p>While the following example demonstrates many features of
      parameter objects, it should not be considered to illustrate good
      programming style.  Usually, the conversion procedure should be idempotent.</p>

    <pre class="example">(define p (make-parameter 10 (lambda (x) (* x x))))
(define ps #f)

(p)<span class="result">100</span>

(p 12)
(p)<span class="result">144</span>

(parameterize ([p (p)])
  (set! ps (current-parameterization))
  (p))<span class="result">20736</span>
(p)<span class="result">144</span>

(parameterization? ps)<span class="result">#t</span>

(call-with-parameterization ps
  (lambda ()
    (let ([x (p)])
      (p 0)
      (list x (p)))))<span class="result">(20736 0)</span>

(p)<span class="result">144</span></pre>

    <p>The following example shows how continuation marks can be used
    to test that the last expression in a <code>parameterize</code>
    body is in tail context if the <code>parameterize</code> expression itself is:</p>

<pre class="example">(with-continuation-mark 'in-tail-context? #t
  (parameterize ([(make-parameter 0) 1])
    (call-with-immediate-continuation-mark 'in-tail-context? values)))<span class="result">#t</span></pre>

    <p><i>Note:</i> The parameter objects defined in this specification are
      fully compatible with the parameter objects
      of <a href="#feeley2"><cite>SRFI 39</cite></a>
      and <cite>R<sup>7</sup>RS</cite> but add the requirement that the last
      expression in the body of a <code>parameterize</code> expression in tail
      context is in tail context as well.  With respect to multiple threads,
      this specification differs from <cite>Racket</cite> in that the cells
      associated with parameter objects are not “thread-local” in this
      specification.  As has already been observed by Marc Feeley during the
      discussion period of <cite>SRFI 39</cite>, this is the cleaner, faster,
      and more expressive semantics.  Finally, the parameter objects defined
      here are not fully compatible with the parameters of <cite>Chez
      Scheme</cite>.  While these offer some features over the parameter
      objects in <cite>SRFI 39</cite> and <cite>R<sup>7</sup>RS</cite>, they
      would be incompatible with the tail-context guarantee of
      the <code>parameterize</code> form.</p>

    <h3>Initial Continuations</h3>

    <p>This section describes the <code>(srfi :226 control
	call-in-initial-continuation)</code> library.  The library, in
	addition to the procedures and syntax described here, also
	exports the <code>&uncaught-exception</code> condition type
	and associated procedures from <code>(srfi :226 control
	threads)</code>.</p>

    <p>An <dfn>initial continuation</dfn> is one that consists of a
      single continuation prompt tagged with the default prompt tag
      and with the default handler.  Moreover, a single initial
      exception handler is installed in an initial continuation that,
      when invoked on a <code>&amp;serious</code> condition or on a
      non-condition object, aborts to the most recent continuation
      prompt tagged with the default prompt tag and calls its handler
      with a thunk that, when evaluated, raises an exception whose
      condition is the object.  When invoked on a
      non-<code>&amp;serious</code> condition object, the initial
      handler returns with unspecified values instead.</p>

    <p><i>Note:</i> There is usually more than one initial
    continuation.  The primordial thread starts in an initial
    continuation, but new initial continuations are created when new
    threads or new promises are created or when the
    procedure <code>call-in-initial-continuation</code> is invoked
      (see below).</p>

    <p>Executing a top-level program starts with the initial
      continuation.  When values are delivered in the initial
      continuation, the program exits normally.  When an exception is
      raised in the dynamic extent of the handler of the initial
      continuation prompt, the program may exit or may provide a
      choice of other options.  It is expected that the initial
      exception handler reports that an exception has been raised, and
      displays information about the condition object that was
      provided.</p>

    <p>This extends the semantics of <code>raise</code>.</p>

    <dl class="entries">
      <dt class="entry"><code>(call-in-initial-continuation <var>thunk</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Calls <code><var>thunk</var></code> in an initial
	  continuation.  The parameterization of the initial
	  continuation is the same as the parameterization of the
	  continuation of the call
	  to <code>call-in-initial-continuation</code>.  When values
	  are delivered to the initial continuation, the values are
	  delivered to the continuation of the call
	  to <code>call-in-initial-continuation</code>.  When an
	  exception is raised in the dynamic extent of the handler of
	  the continuation prompt of the initial continuation,
	  an <code>&uncaught-exception-error</code> condition whose
	  reason is the raised object is raised in the continuation of
	  the call to <code>call-in-initial-continuation</code>.</p>
	<p>This extends the semantics of <code>raise</code>.</p>
      </dd>
    </dl>

<pre class="example">(let ([tag (make-continuation-prompt-tag)]
      [p (make-parameter 0)])
  (parameterize ([p 1])
    (call-in-initial-continuation
      (lambda ()
        (list (continuation-prompt-available? (call/cc values))
              (p))))))<span class="result">(#f 1)</span>

(guard (c
        [(uncaught-exception-error? c) (uncaught-exception-error-reason c)])
  (call-in-initial-continuation
    (lambda ()
      (raise 42))))<span class="result">42</span></pre>

    <h3>Promises</h3>

    <p>This section describes the <code>(srfi :226 control
	promises)</code> library. The library, in addition to the
      procedures and syntax described here, also exports
      the <code>&uncaught-exception</code> condition type and
      associated procedures from <code>(srfi :226 control threads)</code>.</p>

    <p><dfn>Promises</dfn> are objects that can be <dfn>forced</dfn>
      to deliver values or raise exceptions.</p>

    <dl class="entries">
      <dt class="syntax"><code>(delay <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> is a body.</p>
	<p><i>Semantics:</i> Evaluates to a promise that behaves as
	  follows when forced in a continuation <var>k</var>: If the promise
	  already has delivered values, the same values are delivered
	  again, and if the promise already has raised an exception,
	  the same exception is raised again in the continuation <var>k</var>.
	  Otherwise, <code><span class="token">body</span></code> is
	  evaluated in an initial continuation.  The parameterization
	  of the initial continuation is the same as the
	  parameterization of the continuation of the
	  original <code>delay</code> expression.  When values are
	  delivered to the initial continuation and the promise still
	  hasn't delivered values or has raised an exception, the
	  values are delivered to the continuation in which the
	  promise was forced.  Otherwise, the already delivered values
	  are delivered again, or the already raised exception is
	  raised again in the continuation <var>k</var>.  When an exception
	  is raised in the dynamic extent of the handler of the
	  continuation prompt of the initial continuation and the
	  promise still hasn't delivered values or has raised an
	  exception, an <code>&uncaught-exception-error</code>
	  condition whose reason is the object is raised in the
	  continuation <var>k</var>.  Otherwise,
	  the already delivered values are delivered again, or the
	  already raised exception is raised again in the
	  continuation <var>k</var>.</p>

	<p>If a call to <code>force</code> occurs in tail context
	  during the evaluation
	  of <code><span class="token">body</span></code>, it is
	  effectively a tail call.</p>

	<p>All operations involved in forcing except for the
	  evaluation of the body are required to be atomic.</p>

	<p><i>Note: </i> The extra requirement about calls
	  to <code>force</code> in tail contexts makes the
	  extra <code>delay-force</code> syntax
	  of <cite>R<sup>7</sup>RS</cite> (see
	  also <cite>SRFI 45</cite>, where it
	  is called <code>lazy</code>) unnecessary.</p>
      </dd>

      <dt class="procedure"><code>(make-promise <var>obj</var> &hellip;)</code></dt>
      <dd>
	<p>Returns a promise that, when forced in a continuation,
	delivers the values <code><var>obj</var></code> &hellip; to the
	continuation.</p>
	<p><i>Note:</i>
	  <cite>R<sup>7</sup>RS</cite> includes the description of a
	  one-argument procedure also named <code>make-promise</code> that
	  behaves as the <code>make-promise</code> procedure defined
	  here when applied to a single non-promise object.  As the
	  semantics of <code>make-promise</code>
	  in <cite>R<sup>7</sup>RS</cite> makes it mostly useless and
	  does not allow the obvious generalization to multiple
	  values, we have decided to break compatibility for the
	  better.
	</p>
      </dd>

      <dt class="procedure"><code>(promise? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	promise, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(force <var>promise</var>)</code></dt>
      <dd>
	<p>The <code>force</code> procedure
	forces <code><var>promise</var></code> in the continuation of
	the call to <code>force</code>.</p>
      </dd>
    </dl>

    <p><i>Note:</i>
      <cite>R<sup>7</sup>RS</cite> includes the unfortunate
      requirement that the body of a <code>delay</code> form has to be
      evaluated in the dynamic environment of the call
      to <code>force</code>.  This makes the result of forcing a
      promise dependent on the time when the promise is forced even in
      purely functional code.  As has already been observed Marc
      Feeley during the discussion period of <cite>SRFI 39</cite>, the
      more consistent semantics would have been to evaluate the body
      of a <code>delay</code> form in the parameterization of that
      form.  The <code>delay</code> syntax defined in this
      specification has the more consistent semantics and is breaking
      compatibility with <cite>R<sup>7</sup>RS</cite> for what we
      think is the better.  The semantics defined here also work well
      in the presence of capturing and applying continuations.  In
      fact, with regard to the dynamic environment, the semantics of
      promises are now equivalent to that of threads.</p>

    <pre class="example">(promise? (make-promise 1 2))<span class="result">#t</span>
(promise? (delay 3))<span class="result">#t</span>
(promise? (force (make-promise (make-promise 4))))<span class="result">#t</span>

(call-with-values
    (lambda ()
      (force
       (delay
         (define x 1)
         (values x 2))))
  list)<span class="result">(1 2)</span>

(let* ([p (make-parameter 3)]
       [q (parameterize
              ([p 5])
            (delay (p)))])
  (force q))<span class="result">5</span>

(let* ([x 0]
       (q (delay
            (set! x (+ x 1))
            (raise #t))))
  (guard (c [(uncaught-exception-error? c)])
    (force q)
    (set! x (+ x 2)))
  (guard (c [(uncaught-exception-error? c)])
    (force q)
    (set! x (+ x 4)))
  x)<span class="result">1</span></pre>

    <h3>Exceptions</h3>

    <p>This section describes the <code>(srfi :226 control
	exceptions)</code> library.</p>

    <p>Conceptually, each continuation contains at least one
      otherwise inaccessible exception handler stack continuation
      mark, whose value is a list of exception handlers,
      which are one-argument procedures.  The <dfn>exception handler
      stack</dfn> of a continuation is the value of the most recent
      exception handler stack continuation mark in the continuation.
      The exception handler stack of the current continuation is
      the <dfn>current exception handler stack</dfn>.
      The <dfn>current exception handler</dfn> is the first element of
      the current exception handler stack.  An exception handler
      (procedure) is <dfn>installed</dfn> in a continuation by
      recording the exception handler stack of the continuation,
      constructing a new exception handler stack by prepending the
      exception handler to be installed to the recorded exception
      handler stack, and annotating the continuation with an exception
      handler stack continuation mark whose value is the new exception
      handler stack.  The most recent exception handler
      is <dfn>removed</dfn> in a continuation by recording the
      exception handler stack of the continuation, constructing a new
      exception handler stack by removing the first element of the
      recorded exception handler stack, and annotating the continuation
      with an exception handler stack continuation mark whose value is
      the new exception handler stack.</p>

    <dl class="entries">
      <dt class="procedure"><code>(with-exception-handler <var>handler</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>It is an assertion violation
	if <code><var>handler</var></code> is not a procedure or does not
	accept one argument.</p>
	<p>Installs <code><var>handler</var></code> in the
	  continuation to the call
	  to <code>with-exception-handler</code>,
	  calls <code>thunk</code> with no arguments, and delivers the
	  resulting values to the continuation of the call
	  to <code>with-exception-handler</code>.
	</p>
	<p>If a call
	  to <code>with-exception-handler</code> occurs in a tail
	  context, the call to <code><var>thunk</var></code> is also in a tail
	  context.</p>
	<p><i>Note:</i> The tail context requirement is neither
	  in <cite>R<sup>6</sup>RS</cite> nor
	  in <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
      <dt class="procedure"><code>(exception-handler-stack)</code></dt>
      <dd>
	<p>Returns a newly allocated list containing the handlers of
	  the current exception handler stack, with the most recently
	  installed handlers coming first.</p></dd>
      <dt class="procedure"><code>(current-exception-handler)</code></dt>
      <dd><p>Returns the current exception handler.</p>
      </dd>
      <dt class="procedure"><code>(raise <var>obj</var>)</code></dt>
      <dd>
	<p>Raises a <dfn>non-continuable exception</dfn> as follows:
	  The current exception handler is recorded and then the most
	  recent exception handler is removed in the continuation
	  to the call to <code>raise</code>.  The recorded exception
	  handler is then invoked on <code><var>obj</var></code>.  If
	  this invocation returns, a non-continuable exception with
	  condition type <code>&amp;non-continuable</code> is raised
	  in the continuation of the call to <code>raise</code>.
	</p>
	<p>If there is no current exception handler because the
	  current exception handler stack is empty, the current
	  continuation is instead aborted to the most recent
	  continuation prompt tagged with the default continuation
	  prompt tag, and its handler invoked on a thunk that, when called,
	  raises <code><var>obj</var></code>.</p>
	<p><i>Note:</i> The current exception handler stack becomes
	  empty if the initial exception handler returns after having
	  been invoked on a non-<code>&amp;serious</code> condition,
	  which causes a <code>&amp;non-continuable</code> condition to
	  be raised.</p>
      </dd>
      <dt class="procedure"><code>(raise-continuable <var>obj</var>)</code></dt>
      <dd>
	<p>Raises a <dfn>continuable exception</dfn> as follows:
	  The most recent continuation frame in the continuation to
	  the call to <code>raise-continuable</code> is annotated with an
	  exception handler stack continuation mark whose value is the
	  current handler stack with the first element removed.  The
	  previously first element is then invoked
	  on <code><var>obj</var></code>, and its values are returned.</p>
	<p>If there is no current exception handler because the
	  current exception handler stack is empty, the current
	  continuation is instead aborted to the most recent
	  continuation prompt tagged with the default continuation
	  prompt, and its handler invoked on a thunk that, when called,
	  raises <code><var>obj</var></code>.</p>
	<p>If a call to <code>raise-continuable</code> occurs in a
	  tail context, the call to the current exception handler is
	  also in a tail context.</p>
	<p><i>Note: </i> The tail context requirement is neither
	  in <cite>R<sup>6</sup>RS</cite>, nor
	  in <cite>R<sup>7</sup>RS</cite>.  It is
	  in <cite>SRFI 18</cite>,
	  whose <code>raise</code> corresponds
	  to <code>raise-continuable</code>
	  in <cite>R<sup>6</sup>RS</cite>
	  and <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
      <dt class="syntax"><code>(guard
	  (<span class="token">variable</span> <span class="token">cond
	  clause<sub>1</sub></span> <span class="token">cond
	    clause<sub>2</sub></span>) <span class="token">body</span>)</code></dt>
      <dt class="entry"><code>=&gt;</code><span class="type">auxiliary syntax</span></dt>
      <dt class="entry"><code>else</code><span class="type">auxiliary syntax</span></dt>
      <dd>
	<p><i>Syntax:</i> Each <code><span class="token">cond
	  clause</span></code> is as in the specification
	  of <code><span class="token">cond</span></code>.  <code><span class="token">Variable</span></code>
	  is an identifier
	  and <code><span class="token">body</span></code> a body.</p>
	<p><i>Semantics:</i> Installs an exception handler as
	  described below in the continuation of
	  the <code>guard</code> expression, and
	  evaluates <code><span class="token">body</span></code>.  The
	  installed exception handler captures and records the current
	  continuation delimited by the default prompt tag.  It then
	  aborts to the continuation of the <code>guard</code>
	  expression or to the most recent continuation prompt tagged
	  with the default prompt tag, whatever comes first.  It then
	  binds the raised object
	  to <code><span class="token">variable</span></code> and,
	  within the scope of that binding, evaluates the clauses as
	  if they were the clauses of a <code>cond</code> expression.
	  If every <code><span class="token">cond clause</span></code>
	  evaluates to <code>#f</code> and there is
	  no <code>else</code> clause, the recorded continuation is
	  reinstated with the most recent exception handler removed
	  and a continuable exception with the same object originally
	  raised is raised in the resulting continuation.  Otherwise,
	  the resulting values of the equivalent <code>cond</code>
	  expression are delivered to the aborted continuation (the
	  one captured and recorded).</p>
	<p>If a <code>guard</code> expression is in tail context, the
	  last expression
	  in <code><span class="token">body</span></code> is in tail
	  context as well.  The final expression in
	  a <code><span class="token">cond clause</span></code> is in
	  a tail context if the <code>guard</code> expression itself
	  is.</p>
	<p><i>Note:</i> The tail context requirement on the body of
	  a <code>guard</code> expression is neither
	  in <cite>R<sup>6</sup>RS</cite>, nor
	  in <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
    </dl>

    <pre class="example">(guard (c [(eqv? c 42) c])
  (+ 1
     (call-with-continuation-prompt
       (lambda ()
         (raise 42)))))<span class="result">43</span></pre>

    <h3>Threads</h3>

    <p>This section describes the <code>(srfi :226 control
	threads)</code> library.  The library is compatible and mostly
      API-compatible with <cite>SRFI 18</cite>.  For detailed
      examples and a detailed rational, please see that SRFI.  The
      author of this document does not claim any additional major
      contributions; in fact, a lot of text from <cite>SRFI
	18</cite> was copied verbatim or mostly verbatim.</p>

    <p>The concepts of a <i>thread</i>, a <i>mutex</i>, and a
      condition variable are described in the corresponding
      subsections below.  As in <cite>SRFI 18</cite>, we do not
      require specific fairness constraints from implementations of
      this SRFI.  Please see <cite>SRFI 18</cite> for more comments on
      fairness.</p>

    <p>The API described in this sections differs from the API provided by <cite>SRFI 18</cite> in the following points:</p>

    <ul>
      <li><p>Neither threads, mutexes, nor condition variables possess
	  a <code>name</code> field.  If such information is needed for
	  debugging purposes, a weak hash table should be used
	  instead.</p></li>
      <li><p>Neither threads, mutexes, not condition variables
	  possess <code>specific</code> fields.  If these are needed,
	  weak hash tables could be used instead.  Moreover, this SRFI
	  describes thread locals as a mechanism to associate data
	  with threads.  In fact, thread locals allow library-specific
	  and not only application-specific data as the
	  thread-specific field of <cite>SRFI 18</cite>.</p></li>
      <li><p>(Absolute) time objects are not supported.  They can be
      replaced by relative times (given in seconds as real numbers)
	  relative to the current time.</p></li>
      <li><p>No time-related procedures are provided.  Instead, the
	  procedures exported by the library <code>(scheme
	  time)</code> of <cite>R<sup>7</sup>RS</cite> can be used,
	  for example.</p></li>
      <li><p>The procedures related to exception handling contained
	  in <cite>SRFI 18</cite> are described elsewhere in this
	  document.</p></li>
      <li><p>The exception objects of <cite>SRFI 18</cite> are
	  replaced by equivalent condition objects following the hierarchy
	  of standard condition types of <cite>R<sup>6</sup>RS</cite>.</p></li>
      <li><p>The procedure <code>thread-join!</code> does not have the
      optional <code><var>timeout-val</var></code> argument.  The
      procedure <code>mutex-state</code> never delivers the owner
      thread; instead a procedure <code>mutex-owner</code> is provided
      for this purpose.</p></li>
    </ul>

    <p>A <dfn>timeout</dfn> is represented either by a real number
      (object) or by <code>#f</code>.  If it is a real number, a
      relative time in a number of seconds given by the real number is
      represented (negative numbers the represented time is in the
      past relative to the current time).  If it is <code>#f</code>,
      an absolute time lying infinitely far in the future is
      represented (meaning effectively no timeout).  A missing
      optional timeout value defaults to <code>#f</code>.</p>

    <h4>Conditions</h4>

    <dl class="entries">
      <dt class="entry"><code>&amp;thread</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread &amp;error
  make-thread-error thread-error?)</pre>
	<p>This is a supertype for a set of more specific thread errors.</p>
      </dd>
      <dt class="entry"><code>&amp;uncaught-exception</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-uncaught-exception-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(uncaught-exception-error? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(uncaught-exception-error-reason <var>condition</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;uncaught-exception &amp;thread
  make-uncaught-exception-error uncaught-exception-error?
  (reason uncaught-exception-reason))</pre>
	<p>Both <code>uncaught-exception-error?</code>
	  and <code>uncaught-exception-error-reason</code> are the
	  same as <code>uncaught-exception</code>
	  and <code>uncaught-exception-reason</code>
	  in <cite>SRFI 18</cite>.</p>
	<p><i>Note:</i> The names defined in this specification are
	  more in line with the naming conventions
	  in <cite>R<sup>6</sup>RS</cite>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-already-terminated</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-already-terminated-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-already-terminated-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-already-terminated &amp;thread
  make-thread-already-terminated-error thread-already-terminated-error?)</pre>
	<p>The procedure <code>thread-already-terminated-error?</code>  is the same
	  as <code>terminated-thread-exception?</code>
	  in <cite>SRFI 18</cite>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-timeout</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-timeout-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-timeout-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-timeout &amp;thread
  make-thread-timeout-error thread-timeout-error?)</pre>
	<p>The procedure <code>thread-timeout-error?</code>  is the same
	  as <code>join-timeout-exception?</code>
	  in <cite>SRFI 18</cite>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-abandoned-mutex</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-abandoned-mutex-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-abandoned-mutex-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-abandoned-mutex &amp;thread
  make-thread-abandoned-mutex-error thread-abandoned-mutex-error?)</pre>
	<p>The procedure <code>thread-abandoned-mutex-error?</code>  is the same
	  as <code>abandoned-mutex-exception?</code>
	  in <cite>SRFI 18</cite>.</p>
      </dd>
      <dt class="entry"><code>&amp;concurrent-modification</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-concurrent-modification-violation)</code></dt>
      <dt class="procedure"><code>(concurrent-modification-violation? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;concurrent-modification-violation &amp;assertion
	  make-concurrent-modification-violation concurrent-modification-violation?)</pre>
	<p>A <code>&amp;concurrent-modification</code> violation is
	  raised when a concurrent modification of a non-thread safe
	  data structure is detected.</p>
      </dd>
    </dl>

    <p>The following example gives an implementation
    of <code>list-&gt;vector</code> utilizing <code>&amp;concurrent-modification</code>:</p>

    <pre class="example">(define list-&gt;vector
  (lambda (ls)
    (define-syntax safe
      (syntax-rules ()
        [(safe expr)
         (guard (exc [(assertion-violation? exc)
                      (raise
                        (condition
                          (make-who-condition 'list-&gt;vector)
                          (make-message-condition "argument concurrently modified")
                          (make-irritants-condition (list ls))
                          (make-concurrent-modification-violation)))])
           expr)]))
    (let ([n (length ls)])
      (do ([v (make-vector n)]
           [i 0 (fx+ i 1)]
           [ls ls (safe (cdr ls))])
          ((fx=? i n) v)
        (vector-set! v i (safe (car ls)))))))</pre>

    <h4>Threads</h4>

    <p>A <dfn>thread</dfn> is a Scheme value of a specific type,
      representing a virtual processor which shares object space with all other threads.</p>

    <p> A <dfn>running</dfn> thread is a thread that is currently
    executing. There can be more than one running thread on a
    multiprocessor machine.  A <dfn>runnable</dfn> thread is a thread
    that is ready to execute or running.  A thread
    is <dfn>blocked</dfn> if it is waiting for a mutex to become
    unlocked, an I/O operation to become possible, the end of
    a <i>sleep</i> period, etc.  A <dfn>new</dfn> thread is a thread
    that has not yet become runnable.  A new thread becomes runnable
    when it is started.  A <dfn>terminated</dfn> thread is a thread
    that can no longer become runnable (but "deadlocked" threads are
    not considered terminated).

    <p>The only valid transitions between the thread states are from
      new to runnable, between runnable and blocked, and from any
      state to terminated.  Any attempt to cause an invalid transition
      raises an assertion violation.</p>

    <dl class="entries">
      <dt class="entry"><code>(make-thread <var>thunk</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns a new thread.  This thread is not automatically
	  made runnable (the procedure <code>thread-start!</code> must be
	  used for this).</p>
	<p>The thread's execution consists of a call
	  to <code><var>thunk</var></code> in an initial continuation
	  as defined above.  The parameterization of the initial
	  continuation is the same as the parameterization of the
	  continuation of the invocation of <code>make-thread</code>.
	  When an exception <var>e</var> is raised in the dynamic
	  extent of the handler of the initial continuation prompt,
	  an <code>&amp;uncaught-exception</code> error object is recorded to be
	  raised for this thread and the thread finally
	  terminated.  The <code>reason</code> field of
	  the <code>&amp;uncaught-exception</code> error object is
	  populated with the exception <var>e</var>.  When values are
	  delivered to the initial continuation, the values are
	  recorded to be delivered for this thread and the thread
	  is finally terminated.</p>
	<p>When a thread is finally terminated, all mutexes it owns are abandoned.</p>
	<p>This extends the semantics of <code>raise</code>.</p>
      </dd>
      <dt class="entry"><code>(thread <span class="token">body</span>)</code><span class="type">syntax</span></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> is a body.</p>
	<p><i>Semantics:</i> Operationally equivalent to
	  evaluating <code>(make-thread (lambda () <span class="token">body</span>))</code>.</p>
	<p><i>Note:</i> As threads inherit the parameterization of
	  when they are created, a <code>thread</code> expression
	  conveys the meaning better than a call
	  to <code>make-thread</code>.</p>
      </dd>
      <dt class="entry"><code>(thread? <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd><p>Returns <code>#t</code> if <code><var>obj</var></code> is
      a thread, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="entry"><code>(current-thread)</code><span class="type">procedure</span></dt>
      <dd><p>Returns the current thread.</p>
      </dd>
      <dt class="entry"><code>(thread-start! <var>thread</var>)</code><span class="type">procedure</span></dt>
      <dd><p>Makes <code><var>thread</var></code> runnable and returns
	  it.  The thread <code><var>thread</var></code> must be a new
	  thread.</p>
	<p><i>Note:</i> It is useful to separate thread creation and
	  thread activation to avoid the race condition that would
	  occur if the created thread tries to examine a table in
	  which the current thread stores the created thread.</p>
      </dd>
      <dt class="entry"><code>(thread-yield!)</code><span class="type">procedure</span></dt>
      <dd><p>The current thread exits the running state.  Returns unspecified values.</p></dd>
      <dt class="entry"><code>(thread-sleep! <var>timeout</var>)</code><span class="type">procedure</span></dt>
      <dd><p>The current thread waits until the timeout <var>timeout</var> is
	  reached.  This blocks the thread only if timeout represents
	  a point in the future.  The
	  procedure <code>thread-sleep!</code> returns unspecified
	  values.</p>
	<p>An assertion violation is raised if <code><var>timeout</var></code> is <code>#f</code>.</p>
      </dd>
      <dt class="entry"><code>(thread-terminate! <var>thread</var>)</code><span class="type">procedure</span></dt>
      <dd><p>Schedules an abnormal termination
	  of <code><var>thread</var></code>.  When the termination is
	  due and if the thread is not already terminated, all mutexes
	  owned by the thread become unlocked/abandoned and
	  a <code>&amp;thread-already-terminated</code> error object to be raised
	  is recorded for this thread.</p>
	<p>If thread is the current
	  thread, <code>thread-terminate!</code> does not return.
	  Otherwise, the current thread waits until the
	  termination of <code><var>thread</var></code> has occurred.
	  Afterward, <code>thread-terminate!</code> returns unspecified values.</p>
	<p>If a thread is scheduled for (abnormal) termination and is
	  blocked, the termination is due and the thread terminated
	  before it would be unblocked.</p>
	<p><i>Note:</i> This operation must be used carefully
	  because it terminates a thread abruptly and it is impossible
	  for that thread to perform any kind of cleanup.  This may be a
	  problem if the thread is in the middle of a critical section
	  where some structure has been put in an inconsistent
	  state.  However, another thread attempting to enter this
	  critical section will raise an <code>&amp;thread-abandoned-mutex</code> violation
	  because the mutex is unlocked/abandoned.  This helps avoid
	  observing an inconsistent state.</p>
      </dd>
      <dt class="entry"><code>(thread-join! <var>thread</var> <var>timeout</var>)</code><span class="type">procedure</span></dt>
      <dt class="entry"><code>(thread-join! <var>thread</var>)</code><span class="type">procedure</span></dt>
      <dd><p>The current thread waits
	  until <code><var>thread</var></code> terminates (normally or
	  not) or until the timeout <code><var>timeout</var></code> is
	  reached.  If the timeout is reached,
	  a <code>&amp;thread-timeout</code> error is raised.
	  Otherwise, if an error object to be raised is recorded for
	  this thread, it is raised.  Otherwise, the result values to
	  be delivered that are recorded for this thread are
	  delivered.</p>
      </dd>
    </dl>

    <dl class="entries">
      <dt class="entry"><code>(thread <span class="token">body</span>)</code><span class="type">syntax</span></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> is a body.</p>
	<p><i>Semantics:</i> Operationally equivalent to
	  evaluating <code>(make-thread (lambda
	  () <span class="token">body</span>))</code>.  The initial
	  continuation is an initial continuation as defined above.
	  The parameterization of the initial continuation is the same
	  as the parameterization of the continuation of
	  the <code>thread</code> expression.  When an exception is
	  raised in the dynamic extent of the handler of the initial
	  continuation prompts, a condition with
	  type <code>&amp;uncaught-exception</code> and the raised
	  object as its reason is stored in
	  the <code>end-exception</code> of the thread before the
	  thread is finally terminated.  When values are delivered to
	  the initial continuation, the values are stored in
	  the <code>end-result</code> of the thread before the thread
	  is finally terminated.</p>
	<p>This extends the semantics of <code>raise</code>.</p>
	<p><i>Note:</i> This also defines the initial continuation of
	  a thread created by invoking the <code>make-thread</code>
	  procedure in <cite>SRFI 18</cite>.</p>
	<p><i>Note:</i> As threads inherit the parameterization of
	  when they are created, a <code>thread</code> expression
	  conveys the meaning better than a call
	  to <code>make-thread</code>.</p>
      </dd>
    </dl>

    <pre class="example">(let ([p (make-parameter 0)])
(parameterize ([p 1])
  (let ([y
         (thread-join!
          (thread-start!
           (thread
             (let ([x (p)])
               (p 2)
               x))))])
    (list y (p)))))<span class="result">(1 2)</span></pre>

    <pre class="example">(let [(l '())]
  (define out!
    (lambda (x)
      (set! l (cons x l))))
  (define get
    (lambda ()
      (reverse l)))
  (thread-join!
   (thread-start!
    (thread
      (dynamic-wind
          (lambda ()
            (out! 'in))
          (lambda ()
            (call/cc
             (lambda (k)
               (thread-join!
                (thread-start!
                 (thread
                   (out! 'thread)
                   (k)))))))
          (lambda ()
            (out! 'out))))))
  (get))<span class="result">(in thread in out out)</span></pre>

    <h4>Mutexes</h4>

    <p>A <dfn>mutex</dfn> is a Scheme value of a specific type,
      representing a mutual exclusion device, also known as a lock and
      binary semaphore.</p>

    <p>A mutex can be in one of four states: <dfn>locked</dfn>
      (either <dfn>owned</dfn> or not owned) and <dfn>unlocked</dfn>
      (either <dfn>abandoned</dfn> or not abandoned).  An attempt to
      lock a mutex only succeeds if the mutex is in an unlocked state,
      otherwise the current thread must wait. A mutex in the
      locked/owned state has an associated <dfn>owner thread</dfn>,
      which by convention is the thread that is responsible for
      unlocking the mutex (this case is typical of critical sections
      implemented as "lock mutex, perform operation, unlock mutex").
      A mutex in the locked/not-owned state is not linked to a
      particular thread.  A mutex becomes locked when a thread locks
      it using the <code>mutex-lock!</code> primitive.  A mutex
      becomes unlocked/abandoned when the owner of a locked/owned
      mutex terminates.  A mutex becomes unlocked/not-abandoned when a
      thread unlocks it using the <code>mutex-unlock!</code>
      primitive.  The mutex primitives specified in this SRFI do not
      implement <i>recursive</i> mutex semantics; an attempt to lock a
      mutex that is locked implies that the current thread must wait
      even if the mutex is owned by the current thread (this can lead
      to a deadlock if no other thread unlocks the mutex).</p>

    <dl class="entries">
      <dt class="entry"><code>(make-mutex)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns a new mutex in the unlocked/not-abandoned
	  state.</p>
      </dd>
      <dt class="entry"><code>(mutex? <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  mutex, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="entry"><code>(mutex-owner <var>mutex</var>)</code><span class="type">procedure</span></dt>
      <dd><p>Returns the owner thread of <code><var>mutex</var></code>
	  if <code><var>mutex</var></code> is in the locked/owned state,
	  and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="entry"><code>(mutex-state <var>mutex</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>
	  Returns one of the
	  symbols <code>owned</code>, <code>not-owned</code>, <code>abandoned</code>, <code>not-abandoned</code>,
	  reflecting the state of <code><var>mutex</var></code>.</p>
	<p>
	<p><i>Note:</i> To simplify the type
	  of <code>mutex-state</code>, this procedure differs from the
	  procedure with the same name in <cite>SRFI 18</cite>.
	  Use <code>mutex-owner</code> to access a mutex's owner.</p>
      </dd>
      <dt class="entry"><code>(mutex-lock! <var>mutex</var> <var>timeout</var> <var>owner-thread</var>)</code><span class="type">procedure</span></dt>
      <dt class="entry"><code>(mutex-lock! <var>mutex</var> <var>timeout</var>)</code><span class="type">procedure</span></dt>
      <dt class="entry"><code>(mutex-lock! <var>mutex</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>If <code><var>owner-thread</var></code> is not given, it defaults to <code>#f</code>.</p>
	<p>If <code><var>mutex</var></code> is currently locked, the
	  current thread waits until it is unlocked or until the timeout
	  is reached.  If the timeout is reached, <code>#f</code> is
	  returned.  Otherwise, <code><var>mutex</var></code> becomes
	  locked with <code><var>owner-thread</var></code> as the owner
	  unless <code><var>owner-thread</var></code> is terminated, in which
	  case <code><var>mutex</var></code> becomes
	  unlocked/abandoned.</p>
	<p>After changing the state of the mutex,
	  an <code>&abandoned-mutex</code> error is raised if the
	  mutex was unlocked/abandoned before the state change,
	  otherwise <code>mutex-lock!</code> returns <code>#t</code>.</p>
	<p><i>Note:</i> It is not an error if the
	  mutex is owned by the current thread (but the current thread
	  will have to wait).</p>
      </dd>
      <dt class="entry"><code>(mutex-unlock! <var>mutex</var> <var>condition-variable</var>)</code><span class="type">procedure</span></dt>
      <dt class="entry"><code>(mutex-unlock! <var>mutex</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Unlocks the mutex by making it unlocked/not-abandoned.  If
	  <code><var>condition-variable</var></code> is supplied, the
	  current thread is blocked and added to the
	  <code><var>condition-variable</var></code> before
	  unlocking <code><var>mutex</var></code>; the thread can
	  unblock at any time but no later than when an appropriate
	  call to <code>condition-variable-signal!</code> or
	  <code>condition-variable-broadcast!</code> is performed (see below), and
	  no later than the <code><var>timeout</var></code>.  If there
	  are threads waiting to lock this mutex, the scheduler
	  selects a thread, the mutex becomes locked/owned or
	  locked/not-owned, and the thread is unblocked. <code>mutex-unlock!</code>
	  returns <code>#f</code> when the timeout is reached, otherwise it
	  returns <code>#t</code>.</p>
	<p><i>Note:</i> It is not an error to unlock an unlocked mutex
	  and a mutex that is owned by any thread.</p>
	<p><i>Note:</i> The reason the thread can unblock at any time
	  (when <code><var>condition-variable</var></code> is
	  supplied) is to allow extending this SRFI with primitives
	  that force a specific blocked thread to become runnable.
	  For example a primitive to interrupt a thread so that it
	  performs a certain operation, whether the thread is blocked
	  or not, may be useful to handle the case where the scheduler
	  has detected a serious problem (such as a deadlock) and it
	  must unblock one of the threads (such as the primordial
	  thread) so that it can perform some appropriate action.
	  After a thread blocked on a condition-variable has handled
	  such an interrupt it would be wrong for the scheduler to
	  return the thread to the blocked state, because any calls
	  to <code>condition-variable-broadcast!</code>  during the
	  interrupt will have gone unnoticed.  It is necessary for the
	  thread to remain runnable and return from the call to
	  <code>mutex-unlock!</code> with a result of <code>#t</code>.</p>
	<p><i>Note:</i> <code>mutex-unlock!</code> is related to the
	  <i>wait</i> operation on condition variables available in
	  other thread systems. The main difference is that <i>wait</i>
	  automatically locks the mutex just after the thread is
	  unblocked. This operation is not performed
	  by <code>mutex-unlock!</code>  and so must be done by an
	  explicit call to <code>mutex-lock!</code>.  This has the
	  advantages that a different timeout and exception handler can
	  be specified on the <code>mutex-lock!</code> and <code>mutex-unlock!</code> operations and the
	  location of all the mutex operations is clearly apparent.</p>
      </dd>
    </dl>

    <h4>Condition variables</h4>

    <p>A <dfn>condition variable</dfn> is a Scheme value of a specific type,
      representing a set of blocked threads.</p>

    <p>The blocked threads represented by a condition variable are
      waiting for a certain condition to become true.  When a thread
      modifies some program state that might make the condition true,
      the thread unblocks some number of threads (one or all depending
      on the primitive used) so they can check the value of the
      condition.  This allows complex forms of interthread
      synchronization to be expressed more conveniently than with
      mutexes alone.</p>

    <dl class="entries">
      <dt class="entry"><code>(make-condition-variable)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns a new empty condition variable.</p>
      </dd>
      <dt class="entry"><code>(condition-variable? <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  condition variable, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="entry"><code>(condition-variable-signal! <var>condition-variable</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>If there are threads blocked on <code><var>condition-variable</var></code>, the
	scheduler selects a thread and unblocks it. The
	procedure <code>condition-variable-signal!</code> returns
	  unspecified values.</p>
	<p><i>Note: </i> As their are no fairness constraints imposed
	  on the scheduler by this SRFI, the scheduler may always select
	  the same thread to unblock it.  If in doubt, use <code>condition-variable-broadcast!</code> instead.</p>
      </dd>
      <dt class="entry"><code>(condition-variable-broadcast! <var>condition-variable</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Unblocks all the threads blocked
	  on <code><var>condition-variable</var></code>.  The
	  procedure <code>condition-variable-broadcast!</code> returns
	  an unspecified values.</p>
      </dd>
    </dl>

    <h4>Thread locals</h4>

    <p>The procedures in this subsection are also exported by
      the <code>(srfi :226 control thread-locals)</code> library.</p>

    <p><dfn>Thread locals</dfn> are opaque values used to identify
      thread-specific locations.</p>

    <p>The <dfn>thread-specific storage</dfn> is an opaque table
      associating to each current and future thread and to
      each thread local a cell that holds a value.</p>

    <dl class="entries">
      <dt class="entry"><code>(make-thread-local <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns a thread local that is not <code>equal?</code> to
	any prior or future results
	from <code>make-thread-local</code>.  The
	object <code><var>obj</var></code> is stored the cells
	associated to the thread local in the thread-specific
	storage.</p>
      </dd>
      <dt class="entry"><code>(thread-local? <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a thread local, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="entry"><code>(tlref <var>tl</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Returns the value of the cell associated to the current
	thread and to <code><var>tl</var></code> in the
	thread-specific storage.</p>
      </dd>
      <dt class="entry"><code>(tlset! <var>tl</var> <var>obj</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Sets the value of the cell associated to the current
	  thread and to <code><var>tl</var></code> in the
	  thread-specific storage to <code><var>obj</var></code>.</p>
      </dd>
    </dl>

    <h2 id="implementation">Implementation</h2>

    <h3>Portability</h3>

    <p>Implementing the control operators presented in this SRFI
      solely in terms of the facilities provided in <cite>R<sup>6</sup>RS</cite> or
      <cite>R<sup>7</sup>RS</cite> is not possible.</p>

    <h3 id="sample-implementation">Sample Implementation</h3>

    <p>The sample implementation accompanying this SRFI demonstrates
      how the control operators can be implemented on top of a small
      set of primitives.  If in doubt, it favors simplicity and
      clarity over speed.</p>

    <p>The small set of primitives that have to be provided are as follows:</p>

    <dl class="entries">
      <dt class="procedure"><code>(%call-with-current-continuation <var>proc</var>)</code></dt>
      <dd>
	<p>It is an error if <code><var>proc</var></code> is not a
	procedure taking a single argument.</p>
	<p>Calls <code><var>proc</var></code> with the current undelimited continuation.</p>
	<p>If a call to <code>%call/cc</code> occurs in a tail
	context, the call to <code><var>proc</var></code> is also in a
	  tail context.</p>
	<p>An undelimited continuation is represented by a
	  procedure <code><var>k</var></code> that, when it is later
	  called, abandons whatever undelimited continuation is in
	  effect at that later time and instead reinstates the
	  continuation that is represented by it.</p>

	<p><i>Note:</i> The
	  primitive <code>%call-with-current-continuation</code>
	  neither supports <code>dynamic-wind</code> nor continuation
	  barriers.  It can thus be viewed as
	  the <a href="#clinger"><cite>R4RS</cite></a> procedure with
	  the name <code>call-with-current-continuation</code>.</p>
      </dd>
      <dt class="procedure"><code>(%call-in-continuation <var>k</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>Abandons whatever undelimited continuation is in effect,
	  and calls <code><var>thunk</var></code> with the undelimited
	  continuation represented by <code><var>k</var></code> as the
	  continuation of the call.</p>
      </dd>
      <dt class="procedure"><code>(%continuation=? <var>k<sub>1</sub></var> <var>k<sub>2</sub></var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if the undelimited continuation
	  represented by <code><var>k<sub>1</sub></var></code> is the
	  same as the undelimited continuation represented
	  by <code><var>k<sub>2</sub></var></code>,
	  and <code>#f</code> otherwise.</p>
	<p><i>Note:</i> Procedure equivalence with respect to the
	  standard predicates <code>eq?</code>, <code>eqv?</code>,
	  and <code>equal?</code> is unspecified at least in some
	  versions of the Scheme programming language.</p>
      </dd>

      <dt class="syntax"><code>(%case-lambda-box <span class="token">expression</span> [<span class="token">formals</span>
	  <span class="token">body</span>] ...)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Expression</span></code> is an
	  expression,
	  the <code><span class="token">formals</span></code>s are a
	  formal parameter list and
	  the <code><span class="token">body</span></code>s are
	  bodies.</p>

	<p><i>Semantics:</i>
	  When a <code>%case-lambda-box</code> expression is evaluated,
	  it first
	  evaluates <code><span class="token">expression</span></code>,
	  stores the resulting value in a new location, and then
	  returns a procedure that when later called with some
	  arguments behaves as if the procedure were created by
	  evaluating <code>(case-lambda [<span class="token">formals</span> <span class="token">body</span>] ...)</code>
	  and that is tagged with the new location.</p>
      </dd>

      <dt class="procedure"><code>(%case-lambda-box-ref <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If <var>proc</var> is a procedure tagged with a location,
	  the <code>%lambda-box-ref</code> procedure returns the value
	  stored in this location, and <code>obj</code> otherwise.</p>
      </dd>

    </dl>

    <h3>Other Implementations</h3>

    <p>A lot of the control operators of this SRFI are natively
    implemented in Racket.  A high-performance implementation of
    continuation marks is described in <a href="#flatt"><cite>Compiler
    and runtime support for continuation marks</cite></a>.</p>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>This SRFI borrows heavily from Racket's collection of control
    operators.</p>

    <p>The sample implementation builds upon the ideas presented
      in <cite>A Monadic Framework for Delimited
      Continuations</cite> and found in Racket's CS
      implementation.</p>

    <p>Thanks go to Lassi Kortela for pointing out Marc
      Feeley's <cite>A better API for first-class continuations</cite>
      to me, and to John Cowan and Vladimir Nikishkin for <i>very</i>
      careful readings of the first draft and providing me with a lot
      of helpful comments.</p>

    <p>This document uses text copied verbatim from <cite>SRFI
    18</cite>.</p>

    <p>Finally, I would like to thank Arthur A. Gleckler for
      <a href="https://srfi-email.schemers.org/srfi-224/msg/16888913/">encouraging me</a> to write a SRFI covering delimited
      continuations.</p>

    <h2 id="references">References</h2>

    <ol class="bibliography">
      <li id="chezscheme"><p><a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a>.</p></li>
      <li id="clements"><p>John Clements, Matthew Flatt, Matthias Felleisen: <a href="https://link.springer.com/chapter/10.1007/3-540-45309-1_21"><cite>Modeling an Algebraic Stepper</cite></a>, ESOP 2001: Programming Languages and Systems, pp. 320–334</p></li>
      <li id="clinger">
	<p>William Clinger, Jonathan Rees: <a href="https://standards.scheme.org/official/r4rs.pdf"><cite>Revised<sup>4</sup>
	  Report on the Algorithmic Language Scheme</cite></a>.</p>
      </li>
      <li id="danvy"><p>Olivier Danvy, Andrzej
      Filinski: <cite>Abstracting control</cite>, LFP '90: Proceedings
      of the 1990 ACM conference on LISP and functional programming,
      May 1990,
      pp. 151–160. DOI: <a href="https://doi.org/10.1145/91556.91622">10.1145/91556.91622</a>.</p></li>
      <li id="dybvig">
	<p>R. Kent Dybvig, Simon Peyton Jones, and Amr
	  Sabry: <cite>A monadic framework for delimited
	    continuations</cite>, Journal of Functional Programming, Volume
	  17, Issue 6, November 2007,
	  pp. 687-730. DOI: <a href="https://doi.org/10.1017/S0956796807006259">10.1017/S0956796807006259</a>.</p>
      </li>
      <li id="feeley1">
	<p>Marc
	Feeley: <a href="https://srfi.schemers.org/srfi-18/srfi-18.html"><cite>SRFI
	18: Multithreading support</cite></a>.</p>
      </li>
      <li id="feeley2">
	<p>Marc
	Feeley: <a href="https://srfi.schemers.org/srfi-39/srfi-39.html"><cite>SRFI
	39: Parameter objects</cite></a>.</p>
      </li>
      <li id="feeley3">
	<p>Marc Feeley: <a href="http://www.iro.umontreal.ca/~feeley/papers/FeeleySW01.pdf"><cite>A better API for first-class
	continuations</cite></a>, Scheme and Functional Programming Workshop
	(SFPW'01), pages 1-3, September 2001.
      </li>
      <li id="filinski"><p>Andrzej Filinski: <cite>Representing
      monads</cite>, POPL '94: Proceedings of the 21st ACM
      SIGPLAN-SIGACT symposium on Principles of programming
      languages, February 1994, pp. 446-457. DOI: <a href="https://doi.org/10.1145/174675.178047">10.1145/174675.178047</a>.</p></li>
      <li id="flatt">
	<p>Matthew Flatt, R. Kent Dybvig: <cite>Compiler and runtime
	  support for continuation marks</cite>, PLDI 2020:
	  Proceedings of the 41st ACM SIGPLAN Conference on
	  Programming Language Design and Implementation, June 2020, pp. 45-58. DOI: <a href="https://doi.org/10.1145/3385412.3385981">
	    10.1145/3385412.3385981</a>.</p></li>
      <li id="gasbichler">
	<p>Martin Gasbichler, Michael Sperber: <cite>Final shift for
	  call/cc:: direct implementation of shift and reset</cite>,
	  ACM SIGPLAN Notices, Volume 37, Issue 9, September 2002,
	  pp. 271–282. DOI: <a href="https://doi.org/10.1145/583852.581504">10.1145/583852.581504</a>.</p></li>
      <li id="c17">
        <p><a href="https://www.iso.org/standard/74528.html">ISO/IEC 9899:2018 Information technology — Programming languages — C</a></p>
      </li>
      <li id="kawai">
	<p>Shiro Kawai, John Cowan, Thomas
	Gilray: <a href="https://srfi.schemers.org/srfi-158/srfi-158.html"><cite>SRFI
	158: Generators and Accumulators</cite></a>.</p>
      </li>
      <li id="kelsey1">
	<p>Richard Kelsey, William Clinger, Jonathan Rees (eds.):
	  <cite>Revised<sup>5</sup> Report on the Algorithmic Language
	      Scheme</cite>, ACM SIGPLAN Notices, Volume 33, Issue 9, Sept. 1,
	      1998, pp.
	  26–76. DOI: <a href="https://doi.org/10.1145/290229.290234">10.1145/290229.290234</a>.</p>
      </li>
      <li id="kelsey2">
	<p>Richard Kelsey, Michael Sperber:
	  <a href="https://srfi.schemers.org/srfi-34/srfi-34.html"><cite>SRFI
	      34: Exception Handling for Programs</cite></a>.</p>
      </li>
      <li id="kiselyov">
	<p>Oleg
	Kiselyov: <a href="https://okmij.org/ftp/continuations/against-callcc.html"><cite>An
	argument against call/cc</cite></a>.</p>
      </li>
      <li id="nieper1">
	<p>Marc Nieper-Wißkirchen:
	  <a href="https://srfi.schemers.org/srfi-154/srfi-154.html"><cite>SRFI
	      154: First-class dynamic extents</cite></a>.</p>
      </li>
      <li id="nieper2">
	<p>Marc Nieper-Wißkirchen:
	  <a href="https://srfi.schemers.org/srfi-155/srfi-155.html"><cite>SRFI
	      155: Promises</cite></a>.</p>
      </li>
      <li id="nieper3">
	<p>Marc Nieper-Wißkirchen:
	  <a href="https://srfi.schemers.org/srfi-157/srfi-157.html"><cite>SRFI
	      157: Continuation marks</cite></a>.</p>
      </li>
      <li id="posix">
        <p><a href="http://get.posixcertified.ieee.org/">Portable Operating System Interface (IEEE 1003)</a></p>
      </li>
      <li id="r7rs">
	<p><a href="https://github.com/johnwcowan/r7rs-work/blob/master/R7RSHomePage.md">R7RS Home Page</a>.</p>
      </li>
      <li id="racket">
	<p><a href="https://racket-lang.org/">Racket</a>.</p>
      </li>
      <li id="shinn">
	<p>Alex Shinn, John Cowan, Arthur
	  A. Gleckler: <a href="https://small.r7rs.org/attachment/r7rs.pdf"><cite>Revised<sup>7</sup>
	  Report on the Algorithmic Language Scheme</cite></a>.</p>
      </li>
      <li id="sperber">
	<p>Michael Sperber, R. Kent Dybvig, Matthew Flatt,
	  Anton van Straaten, Robby Findler, and Jacob
	  Matthews: <cite>Revised<sup>6</sup> Report on the Algorithmic
	    Language Scheme</cite>. Journal of Functional Programming,
	  Volume 19, Supplement S1, August 2009,
	  pp. 1-301. DOI: <a href="https://doi.org/10.1017/S0956796809990074">10.1017/S0956796809990074</a>.</p>
      </li>
      <li id="van-horn">
	<p>David van
	Horn: <a href="https://srfi.schemers.org/srfi-97/srfi-97.html"><cite>SRFI
	97: SRFI Libraries</cite></a>.</p>
      </li>
      <li id="van-tonder">
	<p>André van Tonder: <a href="https://srfi.schemers.org/srfi-45/srfi-45.html"><cite>SRFI
	45: Primitives for Expressing Iterative Lazy Algorithms</cite></a>.</p>
      </li>

    </ol>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2021 Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
