<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI XXX: Control Operators</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body
      {
	  font-family: serif;
      }
      span.token
      {
          font-family: serif;
      }
      span.token::before
      {
          content: "⟨";
      }
      span.token::after
      {
          content: "⟩";
      }
      dl.entries dt
      {
	  background-color: lightgrey;
      }
      dl.entries dd
      {
	  margin-left: 0;
      }
      dl.entries > dt.condition-type::after
      {
	  float: right;
	  content: "condition type"
      }
      dl.entries > dt.procedure::after
      {
	  float: right;
	  content: "procedure"
      }
      dl.entries > dt.syntax::after
      {
	  float: right;
	  content: "syntax"
      }
      pre, code
      {
	  font-size: smaller;
      }
      </style>
  </head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>XXX: Control Operators</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <h2 id="abstract">Abstract</h2>

    <p>This SRFI defines a rich set of control operators, which has
      originally been implemented in this form
      in <a href="#racket"><cite>Racket</cite></a>, for the Scheme
      programming language.  This set includes the
      venerable <code>call/cc</code>.</p>

    <p>Prompts delimit continuations,
      and all continuations are conceptually delimited, at the latest
      by the default prompt at the start of each thread.  Instead, continuations
      are divided into composable and non-composable continuations.</p>

    <p>To investigate continuations, this SRFI supports continuation
      marks and offers operators to set and retrieve them.</p>

    <h2 id="issues">Issues</h2>

    <p>None at present.</p>

    <h2 id="rationale">Rationale</h2>

    <p>The aim of this SRFI is to provide a consistent set of control
      operators vastly extending the scope of the venerable pair
      of <code>call/cc</code> and <code>dynamic-wind</code>.  The
      procedures and syntax in this SRFI can be presented as an
      <a href="#sperber"><cite>R<sup>6</sup>RS</cite></a> or as
      an <a href="#shinn"><cite>R<sup>7</sup>RS</cite></a> library,
      which would be named <code>(srfi :XXX control)</code>
      or <code>(srfi XXX)</code>, respectively.  Although a portable
      implementation is not possible, it is demonstrated by the sample
      implementation that a small set of primitives, which can easily
      be provided by any Scheme implementation, suffices to implement
      the rich operators in this SRFI.</p>

    <p>In detail, the contributions of this SRFI are the following:</p>

    <h3>Continuations and Prompts</h3>

    <p>As explained in the <cite>R<sup>6</sup>RS</cite> and
      the <cite>R<sup>7</sup>RS</cite>, whenever a Scheme expression
      is evaluated, there is a <dfn>continuation</dfn> wanting the
      result of the expression.  Each evaluation step can alter the
      current continuation.  For example, non-tail calls let the
      current continuation grow, while returns from non-tail calls let
      it shrink.</p>

    <p>Certain control operations can change the current continuation
      more radically.  The Scheme procedure <code>call/cc</code>
      allows capturing the current continuation and reifies it into a
      procedure that, when later called, abandons the then current
      continuation and replaces it with the captured one.</p>

    <p>Conceptually, only an end segment of the current continuation
      is ever replaced.  For example, when running a Scheme program,
      running a thread, or evaluating an expression at the REPL
      prompt, the old and the new current continuation always share an
      initial segment at least up to the point when the program was
      started, the thread was started, or the expression sent to the
      REPL.</p>

    <p>Therefore, <code>call/cc</code> never has to, nor actually does
      capture the whole current continuation, but only an end segment.
      Reinstating the captured continuation means to replace the end
      segment of the then current continuation.</p>

    <p>With <code>call/cc</code> alone, the programmer has no control
      over the size of this end segment.  This SRFI offers operators
      to exactly do this.  With these operators, the programmer can
      install <dfn>continuation prompts</dfn> identified
      by <dfn>prompt tags</dfn> in the current continuation.  When a
      continuation is later captured, it is delimited by the nearest
      continuation prompt with a given prompt tag.  Default prompts
      are installed at the start of each program, the start of each
      thread, and when expressions are sent to the REPL.</p>

    <h3>Composable and Non-Composable Continuations</h3>

    TBD

    <h3>Continuation Marks</h3>

    TBD

    <h3>Continuations and Threads</h3>

    TBD

    <h3>Parameter Objects</h3>

    <h3>Promises</h3>

    <h3>Implementation</h3>

    <h2 id="specification">Specification</h2>

    <h3>Entry format</h3>

    <p>The following naming conventions imply type restrictions:</p>

    <dl>
      <dt><code><var>obj</var></code>, <code><var>key</var></code></dt>
      <dd>any objects</dd>
      <dt><code><var>name</var></code></dt>
      <dd>symbol</dd>
      <dt><code><var>list</var></code></dt>
      <dd>list</dd>
      <dt><code><var>thunk</var></code>, <code><var>pre-thunk</var></code>, <code><var>post-thunk</var></code></dt>
      <dd>zero-argument procedures</dd>
      <dt><code><var>cont</var></code></dt>
      <dd>continuation</dd>
      <dt><code><var>prompt-tag</var></code></dt>
      <dd>prompt tag</dd>
      <dt><code><var>mark-set</var></code></dt>
      <dd>continuation mark set or <code>#f</code></dd>
      <dt><code><var>parameterization</var></code></dt>
      <dd>parameterization</dd>
      <dt><code><var>promise</var></code></dt>
      <dd>promise</dd>
      <dt><code><var>handler</var></code></dt>
      <dd>procedure or <code>#f</code></dd>
      <dt><code><var>k</var></code></dt>
      <dd>undelimited continuation</dd>
    </dl>

    <h3>Iterators</h3>

    <p>An <dfn>iterator</dfn> for a list in the sense of this
      specification is a zero-argument procedure that returns two
      values on each invocation.  An iterator for the empty list
      returns <code>#f</code> and an iterator for the empty list.  An
      iterator for a non empty list returns the head of the list and
      an iterator for its tail.</p>

    <h3>Conditions</h3>

    <dl class="entries">
      <dt class="condition-type"><code>&amp;continuation</code></dt>
      <dt class="procedure"><code>(make-continuation-condition <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-condition? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-prompt-tag <var>condition</var></code>)</dt>
      <dd>
	<p>
	  This condition type could be defined by
	</p>
	<pre>(define-condition-type &amp;continuation &amp;error
	  make-continuation-condition continuation-condition?
	  (prompt-tag continuation-prompt-tag))</pre>
	<p>
	  This condition type describes errors that occurred during
	  non-local control
	  operations.  <code><var>Prompt-tag</var></code> should be
	  the tag of the delimiting prompt.</p>
      </dd>
    </dl>

    <h3>Prompt Tags</h3>

    <p>Continuation prompts are tagged with <dfn>prompt tags</dfn>,
      which are opaque values.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-prompt-tag)</code></dt>
      <dt class="procedure"><code>(make-continuation-prompt-tag <var>name</var>)</code></dt>
      <dd>
	<p>Returns a prompt tag that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-prompt-tag</code>
	  or <code>default-continuation-prompt-tag</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the prompt tag.
	</p>
      </dd>

      <dt class="procedure"><code>(default-continuation-prompt-tag)</code></dt>
      <dd>
	<p>Returns a constant default prompt tag.</p>
      </dd>

      <dt class="procedure"><code>(continuation-prompt-tag? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  prompt tag, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <h3>Continuation Prompts</h3>

    <p>A <dfn>continuation prompt</dfn> is an active procedure call
      that is tagged with a prompt tag and which records a <dfn>prompt
      handler</dfn>, which is a procedure.</p>

    <p>A continuation prompt with a given prompt tag
      is <dfn>available</dfn> in a continuation if a procedure call
      tagged with the prompt tag is active in
      the continuation.</p>

    <dl class="entries">
      <dt><code>(call-with-continuation-prompt <var>thunk</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var> <var>handler</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	  defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>,
	  and <code><var>handler</var></code> defaults
	  to <code>#f</code>.</p>

	<p>The <code>call-with-continuation-prompt</code> procedure
	  instates an active procedure call that just delivers its
	  arguments to its continuation and that is tagged
	  with <code><var>prompt-tag</var></code> and
	  records <code><var>handler</var></code> with the prompt
	  if <code><var>handler</var></code> is not <code>#f</code>,
	  and with a default handler otherwise, in the current
	  continuation.  Finally, <code><var>thunk</var></code> is
	  called with no arguments in the resulting continuation.</p>

	<p>The default handler is a procedure that takes a single
	  argument <code><var>thunk</var></code>.  When the default
	  handler is called, it reinstates the continuation prompt and
	  calls <code><var>thunk</var></code> with no arguments in the
	  resulting continuation.</p>

	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	context.</p>
      </dd>

      <dt><code>(abort-current-continuation <var>prompt-tag</var> <var>obj<var>
      &hellip;)</code></dt>
      <dd>
	<p>The <code>abort-current-continuation</code> procedure
	  aborts all active procedure calls in the current
	  continuation until a procedure call tagged
	  with <code><var>prompt-tag</var></code> is aborted and
	  replaces them with a call to the handler recorded with the
	  prompt tag with the
	  arguments <code><var>obj</var></code>s.</p>
	<p>
	  When a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the continuation processed
	  by <code>abort-current-continuation</code>, an exception
	  with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p><i>Note:</i> Even if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  current continuation
	  when <code>abort-current-continuation</code> is called, due
	  to the presence of <code>dynamic-wind</code> winders (see
	  below) is can still happen during the aborting process that
	  it becomes no longer available.
	</p>
      </dd>
    </dl>

    <h3>Continuations</h3>

    <p>Each <dfn>continuation (procedure)</dfn> is a procedure.</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-current-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-current-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(call/cc <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call/cc <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The procedure <code>call-with-current-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a procedure call tagged
	  with <code><var>prompt-tag</var></code> as a continuation
	  (“escape”) procedure and passes it as an argument
	  to <code><var>proc</var></code>.  The continuation procedure is a
	  Scheme procedure that, if it is later called, aborts all
	  active procedure calls in the then current continuation up
	  to but not including a procedure call tagged
	  with <code><var>prompt-tag</var></code> or up to but not
	  including a procedure call shared by the current and
	  captured continuations, whichever comes first.  Finally, the
	  active procedure calls in the unshared portion of the
	  captured continuation are reinstated and the arguments
	  supplied to the call to the continuation procedure become the
	  result values for the new current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-current-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation when the continuation procedure is called, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>The identifier <code>call/cc</code> is an alias for <code>call-with-current-continuation</code>.</p>
	<p><i>Note:</i> As a continuation prompt tagged with the
	  default prompt tag is available in the initial continuation
	  of each thread, including the primordial thread,
	  the <code>call-with-current-procedure</code> defined here is
	  a conservative extension of
	  the <code>call-with-current-procedure</code> of earlier
	  Scheme reports.</p>
      </dd>

      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The procedure <code>call-with-composable-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a procedure call tagged
	  with <code><var>prompt-tag</var></code> as a continuation
	  (“escape”) procedure and passes it as an argument
	  to <code><var>proc</var></code>.  The continuation procedure is a
	  Scheme procedure that, if it is later called, the
	  active procedure calls in the
	  captured continuation are reinstated and the arguments
	  supplied to the call to the continuation procedure become the
	  result values for the new current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-current-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p><i>Note:</i> The difference between the continuation
	  procedure returned
	  by <code>call-with-current-continuation</code>
	  and <code>call-with-composable-continuation</code> is that
	  the former removes portions of the then current
	  continuation, while the latter does not.  The former
	  continuation procedures are called <dfn>non-composable
	  continuations</dfn>, while the latter are
	  called <dfn>composable continuations</dfn>.  The latter
	  usually return values to the continuation in which they are
	  called, while the former never do.</p>
      </dd>

      <dt class="procedure"><code>(continuation? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  continuation procedure, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(call-in-continuation <var>cont</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>
	  Aborts and reinstates active procedure calls as if the
	  continuation procedure <code><var>cont</var></code> were
	  applied, but instead of delivering values to then current
	  continuation, the procedure <code><var>thunk</var></code> is
	  called with no arguments in this continuation.</p>
      </dd>

      <dt class="procedure"><code>(call-with-continuation-barrier <var>thunk</var>)</code></dt>
      <dd>
	<p>The <code>call-with-continuation-prompt</code> procedure
	  instates an active procedure call that just delivers its
	  arguments to its continuation and that is marked as
	  a <dfn>continuation barrier</dfn>.  Finally, <code><var>thunk</var></code> is
	  called with no arguments in the resulting continuation.</p>
	<p>When applying a non-composable continuation would reinstate
	  a continuation barrier, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>If a continuation barrier is captured during a call
	to <code>call-with-composable-continuation</code>, an
	exception with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p>This extends the semantics
	  of <code>call-with-current-continuation</code>
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
	<p><i>Note:</i> As calling a composable continuation never
	  aborts active procedure calls, a continuation barrier would
	  be reinstated if and only if the captured continuation
	  included a continuation barrier.</p>
      </dd>

      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var> <var>cont</var>)</code></dt>
      <dd>
	<p>The first form is operationally equivalent to
	  <code>(continuation-prompt-available? <var>prompt-tag</var> (call/cc values))</code>.</p>
	<p>Returns <code>#t</code> if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  continuation packaged in <code><var>cont</var></code> or
	  if <code><var>cont</var></code> is a non-composable
	  continuation delimited
	  by <code><var>prompt-tag</var></code>, and <code>#f</code>
	  otherwise.</p>
      </dd>

      <dt class="procedure"><code>(dynamic-wind <var>pre-thunk</var> <var>thunk</var> <var>post-thunk</var>)</code></dt>
      <dd>
	<p>The <code>dynamic-wind</code> procedure
	  calls <code><var>pre-thunk</var></code> with no arguments in
	  a continuation that calls <code><var>thunk</var></code> with
	  no arguments in a continuation that
	  calls <code><var>post-thunk</var></code> in a continuation
	  with no arguments that finally delivers the results of the
	  call to <code><var>thunk</var></code> to the continuation of
	  the call to <code>dynamic-wind</code>.</p>
	<p>Moreover, when the active call
	  to <code><var>thunk</var></code> is aborted (either due to a
	  prompt abort or a continuation procedure
	  invocation), <code><var>post-thunk</var></code> is called
	  with no arguments, and when the active call
	  to <code><var>thunk</var></code> is reinstated (due to a
	  continuation procedure
	  invocation), <code><var>pre-thunk</var></code> is called
	    with no arguments.</p>
	<p>Each call to <code><var>pre-thunk<var></code>
	  and <code><var>post-thunk</var></code> belongs to the dynamic
	  extent of the original call to <code>dynamic-wind</code>.</p>
	<p><i>Note:</i> When a call
	  to <code><var>pre-thunk</var></code>
	  or <code><var>post-thunk</var></code> returns during a
	  prompt abort or a continuation procedure invocation, the
	  sequence of active procedure calls that still have to be
	  aborted and the sequence of active procedure calls that
	  still have to be reinstated may have changed due to the
	  application of composable continuations captured
	  in <code><var>pre-thunk</var></code>
	  or <code><var>post-thunks</var></code>.
	<p>This extends the semantics
	  of <code>abort-current-continuation</code>, <code>call-with-current-continuation</code>,
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
      </dd>
    </dl>

    <h3>Continuation Marks</h3>

    <p>Active procedure calls can be annotated with <dfn>continuation
	marks</dfn>.  Each continuation mark maps a key, which can be an
      arbitrary object, to a value, which can also be an arbitrary
      object.  If an active procedure call is annotated with a
      continuation mark for a key for which the active procedure call
      has already been annotated with a mark, the most recent annotation
      prevails.</p>

    <dl class="entries">
      <dt class="syntax"><code>(with-continuation-mark <span class="token">key-expr</span> <span class="token">val-expr</span> <span class="token">expression</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Key-expr</span></code>, <code><span class="token">val-expr</span></code>,
	  and <code><span class="token">expression</span></code> must be expressions.</p>
	<p><i>Semantics:</i>
	  <code>Key-expr</code> and <code>val-expr</code> are
	  evaluated in an unspecified order to obtain a key and a
	  value, respectively.  The most recent active procedure call
	  in the continuation of
	  the <code>with-continuation-mark</code> expression is then
	  dynamically annotated with a continuation mark mapping the
	  key to the value, and <code>expression</code> is evaluated
	  in the continuation of
	  the <code>with-continuation-mark</code> expression.</p>
	<p>If a <code>with-continuation-mark</code> expression is in
	tail context, <code>expression</code> is in tail context as
	well.
      </dd>

      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If the most recent active procedure call in the
	continuation of the call
	to <code>call-with-immediate-continuation-mark</code> is
	annotated with a continuation mark mapping <var>key</var> to a
	value, <var>proc</var> is applied to the value, and
	to <var>obj</var> otherwise.</p>
	<p>If a call
	  to <code>call-with-immediate-continuation-mark</code> occurs
	  in a tail context, the call to <code><var>proc</var></code>
	  is also in a tail context.</p>
      </dd>

      <dt class="procedure"><code>(continuation-marks <var>cont</var>)</code></dt>
      <dt class="procedure"><code>(continuation-marks <var>cont</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Returns a continuation mark set capturing the continuation
	  marks of the active procedure calls in the
	  continuation <code><var>cont</var></code> up to the continuation
	    prompt <code>prompt-tag</code>.</p>
	<p>If no continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available
	  in <code><var>cont</var></code>, the
	  continuation <code><var>cont</var></code> must be delimited
	  by <code><var>prompt-tag</var></code> or an exception with
	  condition type <code>&amp;continuation</code> is raised.</p>
      </dd>

      <dt class="procedure"><code>(current-continuation-marks)</code></dt>
      <dt class="procedure"><code>(current-continuation-marks <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Operationally equivalent to <code>(continuation-marks
	(call/cc
	values <var>prompt-tag</var>) <var>prompt-tag</var>)</code>.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	continuation mark set, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Returns a newly allocated list containing the values of the
	  continuation marks for <code><var>key</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding active procedure calls were separated by a
	  continuation prompts
	  tagged <code><var>prompt-tag</var></code>, if at all.  The list
	  elements correspond to the active procedure calls that
	  contained a continuation mark
	  for <code><var>key</var></code> with the most recent active
	  procedure calls coming first.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Returns a newly allocated list containing newly allocated
	  vectors.  The vectors contain the values of the continuation
	  marks for the keys in <code><var>list</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding active procedure calls were separated by a
	  continuation prompts
	  tagged <code><var>prompt-tag</var></code>, if at all, as
	  follows: Each vector contains the continuation marks of a
	  single active procedure call for the keys contained
	  in <code><var>list</var></code>.  If such an active
	  procedure call has no mark for some key
	  in <code><var>list</var></code>, the
	  values <code><var>obj</var></code> is used.  The vectors in
	  the newly allocated list correspond to the active procedure
	  calls that contain a continuation mark for at least one key
	  in <code><var>list</var></code> with the most recent active
	  procedure calls coming first.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag</var></code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Returns an iterator for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments.</p>
	<p><i>Note:</i> Some recent SRFIs that have been included into
	  early editions
	  of <a href="#r7rs"><cite>R<sup>7</sup>RS-large</cite></a> or
	  are to be included its forthcoming editions feature the use
	  of generators (see <a href="">SRFI 158</a>) to process lists
	  (or objects of other sequence types).  As generators are
	  fundamentally non-pure, we believe that their use should be
	  limited in otherwise functional code.  The iterator concept
	  used here, on the other hand, is fully functional.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code> defaults to the value returned
	  by <code>default-continuation-prompt-tag</code>.</p>
	<p>Returns the first element for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments, or <code>obj</code> if
	  the result would be the empty list.</p>
      </dd>
    </dl>

    <h3>Mark Keys</h3>

    <p><dfn>Mark keys</dfn> can be used as opaque keys for
    continuation marks.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-mark-key)</code></dt>
      <dt class="procedure"><code>(make-continuation-mark-key <var>name</var>)</code></dt>
      <dd>
	<p>Returns a mark key that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-mark-key</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the mark key.
	</p>
      </dd>
      <dt class="procedure"><code>(continuation-mark-key? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	mark key, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <h3>Parameter Objects</h3>

    <dl class="entries">
      <dt class="procedure"><code>(make-parameter <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(make-parameter <var>obj</var> <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(make-parameter <var>obj</var> <var>proc</var>)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>
      <dt class="syntax"><code>(parameterize [(<span class="token">id</span> <span class="token">expression</span>) &hellip;] <span class="token">body</span>)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>
      <dt class="procedure"><code>(current-parameterization)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>
      <dt class="procedure"><code>(parameterization? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	parameterization, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="procedure"><code>(call-with-parameterization <var>parameterization</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>TBD</p>
      </dd>
    </dl>

    <p><i>Note:</i>
      TBD: Compatability with SRFI 39, R7RS, Chez Scheme, Racket.</p>

    <h3>Promises</h3>

    <p><dfn>Promises</dfn> are objects that can be <dfn>forced</dfn>
      to deliver values or raise exceptions.</p>

    <dl class="entries">
      <dt class="syntax"><code>(delay <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> must be a body.</p>
	<p><i>Semantics:</i> Evaluates to a promise that behaves as
	  follows when forced in a continuation: If the promise
	  already has delivered values, the same values are delivered
	  again, and if the promise already has raised an exception,
	  the same exception is raised again in the contination.
	  Otherwise, <code><span class="token">body</span></code> is
	  evaluated in a continuation consisting of a single
	  continuation prompt tagged with the value returned
	  by <code>(default-continuation-prompt-tag)</code> and with
	  the default handler.  The parameterization of the initial
	  continuation is the same as the parameterization of the
	  continuation of the original <code>delay</code> expression.
	  Moreover, an initial exception handler is installed in the
	  initial continuation.

	  When values are delivered to the initial continuation and
	  the promise still hasn't delivered values or has raised an
	  exception, the values are delivered to the continuation in
	  which the promise was forced.  Otherwise, the already
	  delivered values are delivered again, or the already raised
	  exception is raised again.

	  When the initial exception handler is invoked on an object
	  and the promise still hasn't delivered values or has raised
	  an exception, the object is raised in the continuation in
	  which the promise was forced.  Otherwiese, the already
	  delivered values are delivered again, or the already raised
	  exception is raised again.</p>

	<p>If a call to <code>force</code> occurs in tail context
	  during the evaluation
	  of <code><span class="token">body</span></code> it is
	  effectively a tail call.</p>

	<p>All operations involved in forcing except for the
	  evaluation of the body are required to be atomic.</p>

	<p><i>Note: </i> The extra requirement about calls
	  to <code>force</code> in tail contexts makes the
	  extra <code>delay-force</code> syntax
	  of <cite>R<sup>7</sup>RS</cite> (see
	  also <a href="van-tonder"><cite>SRFI 45</cite></a>, where it
	  is called <code>lazy</code>) unnecessary.</p>
      </dd>

      <dt class="procedure"><code>(make-promise <var>obj</var> &hellip;)</code></dt>
      <dd>
	<p>Returns a promise that, when forced in a continuation,
	delivers the values <code><var>obj</var></code> &hellip; to the
	continuation.</p>
	<p><i>Note:</i>
	  <cite>R<sup>7</sup>RS</cite> includes the description of a
	  one-argument procedure also named <code>make-promise</code> that
	  behaves as the <code>make-promise</code> procedure defined
	  here when applied to a single non-promise object.  As the
	  semantics of <code>make-promise</code>
	  in <cite>R<sup>7</sup>RS</cite> makes it mostly useless and
	  does not allow the obvious generalization to multiple
	  values, we have decided to break compatibility for the
	  better.
	</p>
      </dd>

      <dt class="procedure"><code>(promise? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	promise, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(force <var>promise</var>)</code></dt>
      <dd>
	<p>The <code>force</code> procedure
	forces <code><var>promise</var></code> in the continuation of
	the call to <code>force</code>.</p>
      </dd>
    </dl>

    <p><i>Note:</i>
      <cite>R<sup>7</sup>RS</cite> includes the unfortunate
      requirement that the body of a <code>delay</code> form has to be
      evaluated in the dynamic environment of the call
      to <code>force</code>.  This makes the result of forcing a
      promise dependent on the time when the promise is forced even in
      purely functional code.  As has already been observed Marc
      Feeley during the discussion period of <cite>SRFI 39</cite>, the
      correct semantics would have been to evaluate the body of
      a <code>delay</code> form in the parameterization of that form.
      The <code>delay</code> syntax defined in this specification has
      the correct semantics and is breaking compatibility
      with <cite>R<sup>7</sup>RS</cite> for what we think is the
      better.  The semantics defined here also work well in the
      presence of capturing and applying continuations.  In fact, with
      regard to the dynamic environment, the semantics of promises are
      now equivalent to that of threads.</p>

    <h2 id="implementation">Implementation</h2>

    <h3>Portability</h3>

    <p>Implementing the control operators presented in this SRFI
      solely in terms of the facilities provided in <cite>R<sup>6</sup>RS</cite> or
      <cite>R<sup>7</sup>RS</cite> is not possible.</p>

    <h3>Sample Implementation</h3>

    <p>The sample implementation accompanying this SRFI demonstrates
      how the control operators can be implemented on top of a small
      set of primitives.  If in doubt, it favors simplicity and
      clarity over speed.</p>

    <p>The small set of primitives that have to be provided are as follows:</p>

    <dl class="entries">
      <dt class="procedure"><code>(%call-with-current-continuation <var>proc</var>)</code></dt>
      <dd>
	<p>It is an error if <code><var>proc</var></code> is not a
	procedure taking a single argument.</p>
	<p>Calls <code><var>proc</var></code> with the current undelimited continuation.</p>
	<p>If a call to <code>%call/cc</code> occurs in a tail
	context, the call to <code><var>proc</var></code> is also in a
	  tail context.</p>
	<p>An undelimited continuation is represented by a
	  procedure <code><var>k</var></code> that, when it is later
	  called, abandons whatever undelimited continuation is in
	  effect at that later time and instead reinstates the
	  continuation that is represented by it.</p>

	<p><i>Note:</i> The
	  primitive <code>%call-with-current-continuation</code> does
	  neither support <code>dynamic-wind</code>, nor continuation
	  barriers.</p>
      </dd>
      <dt class="procedure"><code>(%call-in-continuation <var>k</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>Abandons whatever undelimited continuation is in effect,
	  and calls <code><var>thunk</var></code> with the undelimited
	  continuation represented by <code><var>k</var></code> as the
	  continuation of the call.</p>
      </dd>
      <dt class="procedure"><code>(%continuation=? <var>k<sub>1</sub></var> <var>k<sub>2</sub></var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if the undelimited continuation
	  represented by <code><var>k<sub>1</sub></var></code> is the
	  same as the undelimited continuation represented
	  by <code><var>k<sub>2</sub></var></code>,
	  and <code>#f</code> otherwise.</p>
	<p><i>Note:</i> Procedure equivalence with respect to the
	  standard predicates <code>eq?</code>, <code>eqv?</code>,
	  and <code>equal?</code> is unspecified at least in some
	  versions of the Scheme programming language.</p>
      </dd>

      <dt class="syntax"><code>(%case-lambda-box <span class="token">expression</span> [<span class="token">formals</span>
	  <span class="token">body</span>] ...)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Expression</span></code> must be
	  an
	  expression, the <code><span class="token">formals</span></code>s
	  must be formal parameter lists
	  and the <code><span class="token">body</span></code>s must be
	  bodies.</p>

	<p><i>Semantics:</i>
	  When a <code>%case-lambda-box</code> expression is evaluated,
	  it first
	  evaluates <code><span class="token">expression</span></code>,
	  stores the resulting value in a new location, and then
	  returns a procedure that when later called with some
	  arguments behaves as if the procedure were created by
	  evaluating <code>(case-lambda [<span class="token">formals</span> <span class="token">body</span>] ...)</code>
	  and that is tagged with the new location.</p>
      </dd>

      <dt class="procedure"><code>(%case-lambda-box-ref <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If <var>proc</var> is a procedure tagged with a location,
	  the <code>%lambda-box-ref</code> procedure returns the value
	  stored in this location, and <code>obj</code> otherwise.</p>
      </dd>

    </dl>

    <h3>Other Implementations</h3>

    <p>A lot of the control operators of this SRFI are natively
    implemented in Racket.  A high-performance implementation of
    continuation marks is described in <a href="#flatt"><cite>Compiler
    and runtime support for continuation marks</cite></a>.</p>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>This SRFI borrows heavily from Racket's collection of control
    operators.</p>

    <p>The sample implementation builds upon the ideas presented
      in <a href="#dybvig"><cite>A Monadic Framework for Delimited
      Continuations</cite></a> and found in Racket's CS
      implementation.</p>

    <p>Finally, I would like to thank Arthur A. Gleckler for
      <a href="https://srfi-email.schemers.org/srfi-224/msg/16888913/">encouraging me</a> to write a SRFI covering delimited
      continuations.</p>

    <h2 id="references">References</h2>

    <ol class="bibliography">
      <li id="dybvig">
	<p>R. Kent Dybvig, Simon Peyton Jones, and Amr
	  Sabry: <cite>A monadic framework for delimited
	    continuations</cite>, Journal of Functional Programming, Volume
	  17, Issue 6, November 2007,
	  pp. 687-730. DOI: <a href="https://doi.org/10.1017/S0956796807006259">10.1017/S0956796807006259</a>.</p>
      </li>
      <li id="feeley">
	<p>Marc
	Feeley: <a href="https://srfi.schemers.org/srfi-39/srfi-39.html"><cite>SRFI
	39: Parameter objects</cite></a>.</p>
      </li>
      <li id="flatt">
	<p>Matthew Flatt, R. Kent Dybvig: <cite>Compiler and runtime
	  support for continuation marks</cite>, PLDI 2020:
	  Proceedings of the 41st ACM SIGPLAN Conference on
	  Programming Language Design and Implementation, June 2020, pp. 45-58. DOI: <a href="https://doi.org/10.1145/3385412.3385981">
	    10.1145/3385412.3385981</a>.</p></li>
      <li id="kawai">
	<p>Shiro Kawai, John Cowan, Thomas
	Gilray: <a href="https://srfi.schemers.org/srfi-158/srfi-158.html"><cite>SRFI
	158: Generators and Accumulators</cite></a>.</p>
      </li>
      <li id="r7rs">
	<p><a href="https://github.com/johnwcowan/r7rs-work/blob/master/R7RSHomePage.md">R7RS Home Page</a>.</p>
      </li>
      <li id="racket">
	<p><a href="https://racket-lang.org/">Racket</a>.</p>
      </li>
      <li id="shinn">
	<p>Alex Shinn, John Cowan, Arthur
	  A. Gleckler: <a href="https://small.r7rs.org/attachment/r7rs.pdf"><cite>Revised<sup>7</sup>
	  Report on the Algorithmic Language Scheme</cite></a>.</p>
      </li>
      <li id="sperber">
	<p>Michael Sperber, R. Kent Dybvig, Matthew Flatt,
	  Anton van Straaten, Robby Findler, and Jacob
	  Matthews: <cite>Revised<sup>6</sup> Report on the Algorithmic
	    Language Scheme</cite>. Journal of Functional Programming,
	  Volume 19, Supplement S1, August 2009,
	  pp. 1-301. DOI: <a href="https://doi.org/10.1017/S0956796809990074">10.1017/S0956796809990074</a>.</p>
      </li>
      <li id="kawai">
	<p>André van Tonder: <a href="https://srfi.schemers.org/srfi-45/srfi-45.html"><cite>SRFI
	45: Primitives for Expressing Iterative Lazy Algorithms</cite></a>.</p>
      </li>

    </ol>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2021 Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
