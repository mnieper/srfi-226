<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI XXX: Control Operators</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body
      {
	  font-family: serif;
      }
      span.token
      {
          font-family: serif;
      }
      span.token::before
      {
          content: "⟨";
      }
      span.token::after
      {
          content: "⟩";
      }
      dl.entries dt
      {
	  background-color: lightgrey;
      }
      dl.entries dd
      {
	  margin-left: 0;
      }
      dl.entries > dt.condition-type::after
      {
	  float: right;
	  content: "condition type"
      }
      dl.entries > dt.procedure::after
      {
	  float: right;
	  content: "procedure"
      }
      dl.entries > dt.syntax::after
      {
	  float: right;
	  content: "syntax"
      }
      dt.entry > span.type
      {
	  float: right;
      }
      pre, code
      {
	  font-size: smaller;
      }
      </style>
  </head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>XXX: Control Operators</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <h2 id="abstract">Abstract</h2>

    <p>This SRFI defines a rich set of control operators, which has
      originally been implemented in this form
      in <a href="#racket"><cite>Racket</cite></a>, for the Scheme
      programming language.  This set includes the
      venerable <code>call/cc</code>.</p>

    <p>Prompts delimit continuations,
      and all continuations are conceptually delimited, at the latest
      by the default prompt at the start of each thread.  Instead, continuations
      are divided into composable and non-composable continuations.</p>

    <p>To investigate continuations, this SRFI supports continuation
      marks and offers operators to set and retrieve them.</p>

    <h2 id="issues">Issues</h2>

    <p>None at present.</p>

    <h2 id="rationale">Rationale</h2>

    <p>The aim of this SRFI is to provide a consistent set of control
      operators vastly extending the scope of the venerable pair
      of <code>call/cc</code> and <code>dynamic-wind</code>.  The
      procedures and syntax in this SRFI can be presented as an
      <a href="#sperber"><cite>R<sup>6</sup>RS</cite></a> or as
      an <a href="#shinn"><cite>R<sup>7</sup>RS</cite></a> library,
      which would be named <code>(srfi :XXX control)</code>
      or <code>(srfi XXX)</code>, respectively.  Although a portable
      implementation is not possible, it is demonstrated by the sample
      implementation that a small set of primitives, which can easily
      be provided by any Scheme implementation, suffices to implement
      the rich operators in this SRFI.</p>

    <p>In detail, the contributions of this SRFI are the following:</p>

    <h3>Continuations and Prompts</h3>

    <p>As explained in <cite>R<sup>6</sup>RS</cite> and
      <cite>R<sup>7</sup>RS</cite>, whenever a Scheme expression is
       evaluated, there is a <dfn>continuation</dfn> wanting the
       result of the expression.  We can view a continuation as a
       sequence of active procedure calls.  Each evaluation step can
       alter the current continuation.  For example, calls add an
       active procedure call to the current continuation, while
      returns remove an active procedure call.
    </p>

    <p>Certain control operations can change the current continuation
      more radically.  The Scheme procedure <code>call/cc</code>
      allows capturing the current continuation and reifies it into a
      procedure that, when later called, abandons the then current
      continuation and replaces it with the captured one.</p>

    <p>Conceptually, only an end segment of the current continuation
      is ever replaced.  For example, when running a Scheme program,
      running a thread, or evaluating an expression at the REPL
      prompt, the old and the new current continuation always share an
      initial segment at least up to the point when the program was
      started, the thread was started, or the expression sent to the
      REPL.</p>

    <p>Therefore, <code>call/cc</code> never has to, nor actually does
      capture the whole current continuation, but only an end segment.
      Reinstating the captured continuation means to replace the end
      segment of the then current continuation.</p>

    <p>With <code>call/cc</code> alone, the programmer has no control
      over the size of this end segment.  This SRFI offers operators
      to exactly do this.  With these operators, the programmer can
      install <dfn>continuation prompts</dfn> identified
      by <dfn>prompt tags</dfn> in the current continuation.  When a
      continuation is later captured, it is delimited by the nearest
      continuation prompt with a given prompt tag.  Default prompts
      are installed at the start of each program, the start of each
      thread, and when expressions are sent to the REPL.</p>

    <h3>Composable and Non-Composable Continuations</h3>

    TBD

    <h3>Continuation Marks</h3>

    TBD

    <h3>Continuations and Threads</h3>

    TBD

    <h3>Parameter Objects</h3>

    <h3>Promises</h3>

    <h3>Implementation</h3>

    <h2 id="specification">Specification</h2>

    <h3>Entry format</h3>

    <p>The following naming conventions imply type restrictions:</p>

    <dl>
      <dt><code><var>obj</var></code>, <code><var>key</var></code></dt>
      <dd>any objects</dd>
      <dt><code><var>name</var></code></dt>
      <dd>symbol</dd>
      <dt><code><var>list</var></code></dt>
      <dd>list</dd>
      <dt><code><var>thunk</var></code>, <code><var>pre-thunk</var></code>, <code><var>post-thunk</var></code></dt>
      <dd>zero-argument procedures</dd>
      <dt><code><var>cont</var></code></dt>
      <dd>continuation</dd>
      <dt><code><var>prompt-tag</var></code></dt>
      <dd>prompt tag</dd>
      <dt><code><var>mark-set</var></code></dt>
      <dd>continuation mark set or <code>#f</code></dd>
      <dt><code><var>parameterization</var></code></dt>
      <dd>parameterization</dd>
      <dt><code><var>promise</var></code></dt>
      <dd>promise</dd>
      <dt><code><var>handler</var></code></dt>
      <dd>procedure or <code>#f</code></dd>
      <dt><code><var>k</var></code></dt>
      <dd>undelimited continuation</dd>
    </dl>

    <h3>Iterators</h3>

    <p>An <dfn>iterator</dfn> for a list in the sense of this
      specification is a zero-argument procedure that returns two
      values on each invocation.  An iterator for the empty list
      returns <code>#f</code> and an iterator for the empty list.  An
      iterator for a non empty list returns the head of the list and
      an iterator for its tail.</p>

    <h3>Conditions</h3>

    <p><i>Note:</i> If this SRFI is implemented in a system that does
      not support the condition system of <cite>R6RS</cite>, the
      respective parts of this specification should be
      applied <i>mutatis mutandis</i>.</p>

    <dl class="entries">
      <dt class="entry"><code>&amp;continuation</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-continuation-violation <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-violation? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(continuation-violation-prompt-tag <var>condition</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;continuation &amp;violation
  make-continuation-violation continuation-violation?
  (prompt-tag continuation-violation-prompt-tag))</pre>
	<p>This condition type describes violations that occurred
	  during non-local control
	  operations.  <code><var>Prompt-tag</var></code> should be
	  the tag of the delimiting prompt.</p>
      </dd>
      <dt class="entry"><code>&amp;thread</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread &amp;error
  make-thread-error thread-error?)</pre>
	<p>This is a super type for a set of more specific thread errors.</p>
      </dd>
      <dt class="entry"><code>&amp;uncaught-exception</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-uncaught-exception-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(uncaught-exception-error? <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(uncaught-exception-error-reason <var>condition</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;uncaught-exception &amp;thread
  make-uncaught-exception-error uncaught-exception-error?
  (reason uncaught-exception-reason))</pre>
	<p><code>Uncaught-exception-error?</code>
	  and <code>uncaught-exception-error-reason</code> are the
	  same as <code>uncaught-exception</code>
	  and <code>uncaught-exception-reason</code>
	  in <a href="#feeley1"><cite>SRFI 18</cite></a>.</p>
	<p><i>Note:</i> The names defined in this specification are
	  more in line with the naming conventions
	  in <cite>R<sup>6</sup>RS</cite>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-already-terminated</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-already-terminated-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-already-terminated-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-already-terminated &amp;thread
  make-thread-already-terminated-error thread-already-terminated-error?)</pre>
	<p><code>Thread-already-terminated-error?</code>  is the same
	  as <code>terminated-thread-exception?</code>
	  in <a href="#feeley1"><cite>SRFI 18</cite></a>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-timeout</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-timeout-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-timeout-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-timeout &amp;thread
  make-thread-timeout-error thread-timeout-error?)</pre>
	<p><code>Thread-timeout-error?</code>  is the same
	  as <code>join-timeout-exception?</code>
	  in <a href="#feeley1"><cite>SRFI 18</cite></a>.</p>
      </dd>
      <dt class="entry"><code>&amp;thread-abandoned-mutex</code><span class="type">condition-type</span></dt>
      <dt class="procedure"><code>(make-thread-abandoned-mutex-error <var>obj</var></code>)</dt>
      <dt class="procedure"><code>(thread-abandoned-mutex-error? <var>obj</var></code>)</dt>
      <dd>
	<p>This condition type could be defined by</p>
	<pre>(define-condition-type &amp;thread-abandoned-mutex &amp;thread
  make-thread-abandoned-mutex-error thread-abandoned-mutex-error?)</pre>
	<p><code>Thread-abandoned-mutex-error?</code>  is the same
	  as <code>abandoned-mutex-exception?</code>
	  in <a href="#feeley1"><cite>SRFI 18</cite></a>.</p>
      </dd>
    </dl>

    <h3>Prompt Tags</h3>

    <p>Continuation prompts are tagged with <dfn>prompt tags</dfn>,
      which are opaque values.  A distinguished prompt tag is
      the <dfn>default prompt tag</dfn>.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-prompt-tag)</code></dt>
      <dt class="procedure"><code>(make-continuation-prompt-tag <var>name</var>)</code></dt>
      <dd>
	<p>Returns a prompt tag that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-prompt-tag</code>
	  or <code>default-continuation-prompt-tag</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the prompt tag.
	</p>
      </dd>

      <dt class="procedure"><code>(default-continuation-prompt-tag)</code></dt>
      <dd>
	<p>Returns the default prompt tag.</p>
      </dd>

      <dt class="procedure"><code>(continuation-prompt-tag? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  prompt tag, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <h3>Continuation Prompts</h3>

    <p>We identify a <dfn>continuation</dfn> with a sequence of active
      procedure calls, beginning with the most recent call.  A
      continuation can be uniquely partitioned into
      <dfn>continuation frames</dfn>, which are maximal subsequences
      of active procedure calls containing an arbitrary number of
      active tail calls followed by at most one active non-tail call.</p>

    <p>A <dfn>continuation prompt</dfn> is a type of continuation
      frame so that when values are delivered to a continuation
      extended by such a continuation frame, the values are
      effectively delivered to the non-extended continuation.
      Moreover, each continuation prompt is that is tagged with a
      prompt tag and records a <dfn>prompt handler</dfn>, which
      is a procedure.</p>

    <p>A continuation prompt with a given prompt tag
      is <dfn>available</dfn> in a continuation if a continuation
      prompt with the given tag is contained in the continuation's
      sequence of continuation frames.</p>

    <dl class="entries">
      <dt><code>(call-with-continuation-prompt <var>thunk</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var>)</code></dt>
      <dt><code>(call-with-continuation-prompt <var>thunk</var> <var>prompt-tag</var> <var>handler</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	  defaults to the default prompt tag,
	  and <code><var>handler</var></code> defaults
	  to <code>#f</code>.</p>

	<p>The <code>call-with-continuation-prompt</code> procedure
	  instates a continuation prompt that is tagged
	  with <code><var>prompt-tag</var></code> and
	  records <code><var>handler</var></code> in the continuation
	  to its call.  Finally, <code><var>thunk</var></code> is
	  called with no arguments in the resulting continuation.</p>

	<p>If <code><var>handler</var></code> is <code>#f</code>, the
	  default handler is used instead.  The default handler is a
	  procedure that takes a single
	  argument <code><var>thunk</var></code>.  When the default
	  handler is called, it reinstates the continuation prompt and
	  calls <code><var>thunk</var></code> with no arguments in the
	  resulting continuation.</p>

	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
      </dd>

      <dt><code>(abort-current-continuation <var>prompt-tag</var> <var>obj<var>
      &hellip;)</code></dt>
      <dd>
	<p>The <code>abort-current-continuation</code> procedure
	  aborts all active procedure calls in the current
	  continuation until a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is aborted and
	  replaces them with a call to the handler recorded with the
	  prompt tag with the
	  arguments <code><var>obj</var></code>s.</p>
	<p>
	  When a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the continuation processed
	  by <code>abort-current-continuation</code>, an exception
	  with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p><i>Note:</i> Even if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  current continuation
	  when <code>abort-current-continuation</code> is called, due
	  to the presence of <code>dynamic-wind</code> winders (see
	  below) is can still happen during the aborting process that
	  it becomes no longer available.
	</p>
      </dd>
    </dl>

    <h3>Continuations</h3>

    <p>Each <dfn>continuation (procedure)</dfn> is a procedure.</p>

    <dl class="entries">
      <dt class="procedure"><code>(call-with-current-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-current-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(call/cc <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call/cc <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The procedure <code>call-with-current-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a continuation prompt
	  tagged with <code><var>prompt-tag</var></code> as a
	  continuation (“escape”) procedure and passes it as an
	  argument to <code><var>proc</var></code>.  The continuation
	  procedure is a Scheme procedure that, if it is later called,
	  aborts all active procedure calls in the then current
	  continuation up to but not including a continuation prompt
	  with <code><var>prompt-tag</var></code> or up to but not
	  including an active procedure call shared by the current and
	  captured continuations, whichever comes first.  Finally, the
	  active procedure calls in the unshared portion of the
	  captured continuation are reinstated and the arguments
	  supplied to the call to the continuation procedure become
	  the result values for the new current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-current-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation when the continuation procedure is called, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>The identifier <code>call/cc</code> is an alias for <code>call-with-current-continuation</code>.</p>
	<p><i>Note:</i> As a continuation prompt tagged with the
	  default prompt tag is available in the initial continuation
	  of each thread, including the primordial thread,
	  the <code>call-with-current-procedure</code> defined here is
	  a conservative extension of
	  the <code>call-with-current-procedure</code> of earlier
	  Scheme reports.</p>
      </dd>

      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-composable-continuation <var>proc</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>It is an error if <code><var>proc</var></code> does not accept one argument.</p>
	<p>The
	  procedure <code>call-with-composable-continuation</code>
	  packages all active procedure calls in the current
	  continuation up to but not including a continuation prompt
	  tagged with <code><var>prompt-tag</var></code> as a
	  continuation (“escape”) procedure and passes it as an
	  argument to <code><var>proc</var></code>.  The continuation
	  procedure is a Scheme procedure that, if it is later called,
	  the active procedure calls in the captured continuation are
	  reinstated and the arguments supplied to the call to the
	  continuation procedure become the result values for the new
	  current continuation.
	</p>
	<p>We say that the continuation procedure
	is <dfn>delimited</dfn> by <code><var>prompt-tag</var></code>.</p>
	<p>If a call to <code>call-with-current-continuation</code>
	occurs in a tail context, the call
	to <code><var>proc</var></code> is also in a tail context.</p>
	<p>If a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is not available in
	  the current continuation, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p><i>Note:</i> The difference between the continuation
	  procedure returned
	  by <code>call-with-current-continuation</code>
	  and <code>call-with-composable-continuation</code> is that
	  the former removes portions of the then current
	  continuation, while the latter does not.  The former
	  continuation procedures are called <dfn>non-composable
	  continuations</dfn>, while the latter are
	  called <dfn>composable continuations</dfn>.  The latter
	  usually return values to the continuation in which they are
	  called, while the former never do.</p>
      </dd>

      <dt class="procedure"><code>(continuation? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	  continuation procedure, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(call-in-continuation <var>cont</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>
	  Aborts and reinstates active procedure calls as if the
	  continuation procedure <code><var>cont</var></code> were
	  applied, but instead of delivering values to then current
	  continuation, the procedure <code><var>thunk</var></code> is
	  called with no arguments in this continuation.</p>
      </dd>

      <dt class="procedure"><code>(call-with-continuation-barrier <var>thunk</var>)</code></dt>
      <dd>
	<p>The <code>call-with-continuation-prompt</code> procedure
	  instates an otherwise inaccessible continuation prompt in
	  the current continuation and that is marked as
	  a <dfn>continuation barrier</dfn>.
	  Finally, <code><var>thunk</var></code> is called with no
	  arguments in the resulting continuation.</p>
	<p>When applying a non-composable continuation would reinstate
	  a continuation barrier, an exception with condition
	  type <code>&amp;continuation</code> is raised.</p>
	<p>If a continuation barrier is captured during a call
	to <code>call-with-composable-continuation</code>, an
	exception with condition type <code>&amp;continuation</code> is
	  raised.</p>
	<p>This extends the semantics
	  of <code>call-with-current-continuation</code>
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
	<p><i>Note:</i> As calling a composable continuation never
	  aborts active procedure calls, a continuation barrier would
	  be reinstated if and only if the captured continuation
	  included a continuation barrier.</p>
      </dd>

      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var>)</code></dt>
      <dt class="procedure"><code>(continuation-prompt-available? <var>prompt-tag</var> <var>cont</var>)</code></dt>
      <dd>
	<p>The first form is operationally equivalent to
	  <code>(continuation-prompt-available? <var>prompt-tag</var> (call/cc values))</code>.</p>
	<p>Returns <code>#t</code> if a continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available in the
	  continuation packaged in <code><var>cont</var></code> or
	  if <code><var>cont</var></code> is a non-composable
	  continuation delimited
	  by <code><var>prompt-tag</var></code>, and <code>#f</code>
	  otherwise.</p>
      </dd>

      <dt class="procedure"><code>(dynamic-wind <var>pre-thunk</var> <var>thunk</var> <var>post-thunk</var>)</code></dt>
      <dd>
	<p>The <code>dynamic-wind</code> procedure
	  calls <code><var>pre-thunk</var></code> with no arguments in
	  a continuation that calls <code><var>thunk</var></code> with
	  no arguments in a continuation that
	  calls <code><var>post-thunk</var></code> in a continuation
	  with no arguments that finally delivers the results of the
	  call to <code><var>thunk</var></code> to the continuation of
	  the call to <code>dynamic-wind</code>.</p>
	<p>Moreover, when the active call
	  to <code><var>thunk</var></code> is aborted (either due to a
	  prompt abort or a continuation procedure
	  invocation), <code><var>post-thunk</var></code> is called
	  with no arguments, and when the active call
	  to <code><var>thunk</var></code> is reinstated (due to a
	  continuation procedure
	  invocation), <code><var>pre-thunk</var></code> is called
	    with no arguments.</p>
	<p>Each call to <code><var>pre-thunk<var></code>
	  and <code><var>post-thunk</var></code> belongs to the dynamic
	  extent of the original call to <code>dynamic-wind</code>.</p>
	<p><i>Note:</i> When a call
	  to <code><var>pre-thunk</var></code>
	  or <code><var>post-thunk</var></code> returns during a
	  prompt abort or a continuation procedure invocation, the
	  sequence of active procedure calls that still have to be
	  aborted and the sequence of active procedure calls that
	  still have to be reinstated may have changed due to the
	  application of composable continuations captured
	  in <code><var>pre-thunk</var></code>
	  or <code><var>post-thunks</var></code>.
	<p>This extends the semantics
	  of <code>abort-current-continuation</code>, <code>call-with-current-continuation</code>,
	  and <code>call-with-composable-continuation</code>.</p>
	<p>The calls to the <code><var>thunk</var></code>s are never in tail
	  context.</p>
      </dd>
    </dl>

    <h3>Continuation Marks</h3>

    <p>Continuation frames can be annotated with <dfn>continuation
	marks</dfn>.  Each continuation mark maps a key, which can be
	an arbitrary object, to a value, which can also be an
	arbitrary object.  If a continuation frame is annotated with a
	continuation mark for a key for which the continuation frame
	has already been annotated with a mark, the most recent
	annotation prevails.</p>

    <dl class="entries">
      <dt class="syntax"><code>(with-continuation-mark <span class="token">key-expr</span> <span class="token">val-expr</span> <span class="token">expression</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Key-expr</span></code>, <code><span class="token">val-expr</span></code>,
	  and <code><span class="token">expression</span></code> must be expressions.</p>
	<p><i>Semantics:</i>
	  <code>Key-expr</code> and <code>val-expr</code> are
	  evaluated in an unspecified order to obtain a key and a
	  value, respectively. The most recent continuation frame
	  in the continuation of
	  the <code>with-continuation-mark</code> expression is then
	  dynamically annotated with a continuation mark mapping the
	  key to the value, and <code>expression</code> is evaluated
	  in the continuation of
	  the <code>with-continuation-mark</code> expression.</p>
	<p>If a <code>with-continuation-mark</code> expression is in
	tail context, <code>expression</code> is in tail context as
	well.</p>
      </dd>

      <dt class="syntax"><code>(with-continuation-marks ([<span class="token">key-expr</span> <span class="token">val-expr</span>] &hellip;) <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code>The <span class="token">key-expr</span></code>s and
	  the <code><span class="token">val-expr</span></code>s must
	  be expressions, and <code><span class="token">body</span></code> must
	  be a body.</p>
	<p><i>Semantics:</i> The <code>key-expr</code>s and
	  the <code>val-expr</code>s are evaluated in an unspecified
	  order to obtain a list of keys and a list of corresponding
	  values, respectively. The most recent continuation frame in
	  the continuation of the <code>with-continuation-marks</code>
	  expression is then dynamically annotated with a continuation
	  mark mapping the keys to the values,
	  and <code>body</code> is evaluated in the continuation
	  of the <code>with-continuation-marks</code> expression.</p>
	<p>It is unspecified which value prevails if two of the keys are the
	  same.</p>
	<p>If a <code>with-continuation-marks</code> expression is in
	  tail context, the last expression of <code>body</code> is in
	  tail context as well.</p>
      </dd>

      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(call-with-immediate-continuation-mark <var>key</var> <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If the most recent continuation frame in the continuation
	of the call
	to <code>call-with-immediate-continuation-mark</code> is
	annotated with a continuation mark mapping <var>key</var> to a
	value, <var>proc</var> is applied to the value, and
	to <var>obj</var> otherwise.</p>
	<p>If a call
	  to <code>call-with-immediate-continuation-mark</code> occurs
	  in a tail context, the call to <code><var>proc</var></code>
	  is also in a tail context.</p>
      </dd>

      <dt class="procedure"><code>(continuation-marks <var>cont</var>)</code></dt>
      <dt class="procedure"><code>(continuation-marks <var>cont</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a continuation mark set capturing the continuation
	  marks of the continuation frames in the
	  continuation <code><var>cont</var></code> up to the
	  continuation prompt <code>prompt-tag</code>.</p>
	<p>If no continuation prompt tagged
	  with <code><var>prompt-tag</var></code> is available
	  in <code><var>cont</var></code>, the
	  continuation <code><var>cont</var></code> must be delimited
	  by <code><var>prompt-tag</var></code> or an exception with
	  condition type <code>&amp;continuation</code> is raised.</p>
      </dd>

      <dt class="procedure"><code>(current-continuation-marks)</code></dt>
      <dt class="procedure"><code>(current-continuation-marks <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Operationally equivalent to <code>(continuation-marks
	(call/cc
	values <var>prompt-tag</var>) <var>prompt-tag</var>)</code>.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	continuation mark set, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list <var>mark-set</var> <var>key</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a newly allocated list containing the values of the
	  continuation marks for <code><var>key</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding continuation frames were separated by a
	  continuation prompts
	  tagged <code><var>prompt-tag</var></code>, if at all.  The
	  list elements correspond to the continuation frames that
	  contained a continuation mark
	  for <code><var>key</var></code> with the most recent
	  continuation frame coming first.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;list* <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	  to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns a newly allocated list containing newly allocated
	  vectors.  The vectors contain the values of the continuation
	  marks for the keys in <code><var>list</var></code> captured
	  in <code><var>mark-set</var></code> up to where the
	  corresponding continuation frames were separated by a
	  continuation prompts
	  tagged <code><var>prompt-tag</var></code>, if at all, as
	  follows: Each vector contains the continuation marks of a
	  single continuation frame for the keys contained
	  in <code><var>list</var></code>.  If such a continuation
	  frame has no mark for some key
	  in <code><var>list</var></code>, the
	  values <code><var>obj</var></code> is used.  The vectors in
	  the newly allocated list correspond to the continuation
	  frames that contain a continuation mark for at least one key
	  in <code><var>list</var></code> with the most recent
	  continuation frames coming first.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-&gt;iterator <var>mark-set</var> <var>list</var> <var>obj</var> <var>prompt-tag</var></code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns an iterator for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments.</p>
	<p><i>Note:</i> Some recent SRFIs that have been included into
	  early editions
	  of <a href="#r7rs"><cite>R<sup>7</sup>RS-large</cite></a> or
	  are to be included its forthcoming editions feature the use
	  of generators (see <a href="">SRFI 158</a>) to process lists
	  (or objects of other sequence types).  As generators are
	  fundamentally non-pure, we believe that their use should be
	  limited in otherwise functional code.  The iterator concept
	  used here, on the other hand, is fully functional.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>

      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(continuation-mark-set-first <var>mark-set</var> <var>key</var> <var>obj</var> <var>prompt-tag</var>)</code></dt>
      <dd>
	<p>If not supplied, <code><var>obj</var></code> defaults
	to <code>#f</code>.</p>
	<p>If not supplied, <code><var>prompt-tag</var></code>
	defaults to the default prompt tag.</p>
	<p>Returns the first element for the list that would be
	  constructed by <code>continuation-mark-set-&gt;list</code>
	  when applied to the same arguments, or <code>obj</code> if
	  the result would be the empty list.</p>
	<p>If <code><var>mark-set</var></code> is <code>#f</code>, the
	  mark set that would be returned
	  by <code>(current-continuation-marks <var>prompt-tag</var>)</code>
	  is used instead.</p>
      </dd>
    </dl>

    <h3>Mark Keys</h3>

    <p><dfn>Mark keys</dfn> can be used as opaque keys for
    continuation marks.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-continuation-mark-key)</code></dt>
      <dt class="procedure"><code>(make-continuation-mark-key <var>name</var>)</code></dt>
      <dd>
	<p>Returns a mark key that is not <code>equal?</code> to any
	  prior or future results
	  from <code>make-continuation-mark-key</code>.
	</p>
	<p>
	  The optional <code><var>name</var></code> argument may be
	  used by the implementation for printing the mark key.
	</p>
      </dd>
      <dt class="procedure"><code>(continuation-mark-key? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	mark key, and <code>#f</code> otherwise.</p>
      </dd>
    </dl>

    <h3>Parameter Objects</h3>

    <p>Each <dfn>parameter object</dfn> is a procedure.</p>

    <p>A <dfn>parameterization</dfn> is an opaque mapping of parameter objects
    to cells that hold a value.</p>

    <p>Conceptually, each continuation contains at least one otherwise
      inaccessible parameterization continuation mark, whose value is a
      parameterization.  The <dfn>parameterization of a continuation</dfn> is
      the value of the most recent parameterization continuation mark in the
      continuation.  The parameterization of the current continuation is
      the <dfn>current parameterization</dfn>.

    <p>The parameterization of the initial continuation of a top-level program
      maps each current and future parameter object to a cell holding its
      initial value.</p>

    <dl class="entries">
      <dt class="procedure"><code>(make-parameter <var>obj</var>)</code></dt>
      <dt class="procedure"><code>(make-parameter <var>obj</var> <var>proc</var>)</code></dt>
      <dt class="procedure"><code>(make-parameter <var>obj</var> <var>proc</var>)</code></dt>
      <dd>
	<p>Invokes <code><var>proc</var></code>
	  on <code><var>obj</var></code> to obtain a value and returns
	  a newly allocated parameter object, which is a procedure
	  accepting zero or one argument and whose <dfn>initial
	    value</dfn> is the value and whose <dfn>conversion procedure</dfn> is <code><var>proc</var></code>.</p>
	<p>
	  When a parameter object is invoked with zero arguments, the content
	  of the cell of the parameter object in the parameterization of the
	  invocation is returned.
	</p>
	<p>When a parameter object is invoked with one argument, its conversion
	  function is applied to it to obtain a new value.  The previous value
	  contained in the cell of the parameter object in the parameterization
	  of the invocation is then replaced with the new value.  The result of
	  the invocation is unspecified.</p>
      </dd>

      <dt class="syntax"><code>(parameterize ([<span class="token">param-expr</span> <span class="token">expression</span>] &hellip;) <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  The <code><span class="token">param-expr</span></code>s and
	  the <code><span class="token">expression</span></code>s must be
	  expressions, and <code><span class="token">body</span></code> must be
	  a body.</p>
	<p><i>Semantics:</i> Evaluates
	  the <code><span class="token">param-expr</span></code>s
	  and <code><span class="token">expressions</span></code> in
	  an arbitrary order to obtain parameter objects and values,
	  respectively.  An assertion violation is raised if one of
	  the obtained parameter objects is not actually a parameter
	  object.  For each parameter object, a newly allocated cell
	  is constructed that holds the value of the corresponding
	  expression.  A new parameterization that differs from the
	  parameterization of the continuation of
	  the <code>parameterize</code> expression in mapping the
	  obtained parameter objects to the respectively newly
	  allocated cells is then constructed.  Finally, the most
	  recent continuation frame in the continuation of
	  the <code>parameterize</code> expression is annotated with a
	  parameterization continuation mark whose value is the new
	  parameterization and
	  the <code><span class="token">body</span></code> is
	  evaluated in this continuation.</p>
	<p>It is unspecified which value prevails if two of the
	  parameter objects are the same.</p>
	<p>If a <code>parameterize</code> expression is in tail
	  context, the last expression
	  in <code><span class="token">body</span></code> is in tail
	  context as well.</p>
      </dd>
      <dt class="procedure"><code>(current-parameterization)</code></dt>
      <dd>
	<p>Returns the current parameterization.</p>
      </dd>
      <dt class="procedure"><code>(parameterization? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	parameterization, and <code>#f</code> otherwise.</p>
      </dd>
      <dt class="procedure"><code>(call-with-parameterization <var>parameterization</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>Annotates the most recent continuation frame in the current
	  continuation with a parameterization continuation mark whose
	  value is <code><var>parameterization</var></code>, and
	  invokes <code><var>proc</var></code> in this continuation.
	</p>
	<p>In particular, if a call
	to <code>call-with-current-parameterization</code> occurs in a tail
	context. the call to <code><var>proc</var></code> is also in a tail
	context.</p>
      </dd>
    </dl>

    <p><i>Note:</i> The parameter objects defined in this
      specification are fully compatible with the parameter objects
      of <a href="#feeley2"><cite>SRFI 39</cite></a>
      and <cite>R<sup>7</sup>RS</cite> but add the requirement that
      the last expression in the body of a <code>parameterize</code>
      expression in tail context is in tail context as well.  With
      respect to multiple threads, this specification differs
      from <cite>Racket</cite> in that the cells associated with
      parameter objects are not “thread-local” in this specification.
      As has already been observed by Marc Feeley during the
      discussion period of <cite>SRFI 39</cite> this is the cleaner,
      faster, and more expressive semantics.  Finally, the parameter
      objects defined here are not fully compatible with the
      parameters of <a href="#chez"><cite>Chez Scheme</cite></a>.
      While these offer some features over the parameter objects
      in <cite>SRFI 39</cite> and <cite>R<sup>7</sup>RS</cite>, they
      would be incompatible with the tail context guarantee of
      the <code>parameterize</code> form.</p>

    <h3>Initial Continuations</h3>

    <p>An <dfn>initial continuation</dfn> continuation is continuation
      that consists of a single continuation prompt tagged with the
      default prompt and with the default handler.  Moreover, a single
      initial exception handler is installed in an initial
      continuation that, when invoked on a <code>&amp;serious</code>
      condition or on a non-condition object aborts to the most recent
      continuation prompt tagged with the default prompt tag and calls
      its handler with a thunk that, when evaluated raises an
      exception whose condition is the object.  When invoked on a
      non-<code>&amp;serious</code> condition object, the initial
      handler returns with unspecified values instead.</p>

    <p>Executing a top-level program starts with the initial
      continuation.  When values are delivered in the initial
      continuation, the program exits normally.  When an exception is
      raised in the dynamic extent of the handler of the initial
      continuation prompt, the program may exit or may provide a
      choice of other options.  It is expected that the initial
      exception handler reports than an exception has been raised, and
      displays information about the condition object that was
      provided.</p>

    <p>This extends the semantics of <code>raise</code></p>.

    <dl class="entries">
      <dt class="entry"><code>(call-in-initial-continuation <var>thunk</var>)</code><span class="type">procedure</span></dt>
      <dd>
	<p>Calls <code><var>thunk</var></code> in an initial
	  continuation.  The parameterization of the initial
	  continuation is the same as the parameterization of the
	  continuation of the call
	  to <code>call-in-initial-continuation</code>.  When values
	  are delivered to the initial continuation, the values are
	  delivered to the continuation of the call
	  to <code>call-in-initial-continuation</code>.  When an
	  exception is raised in the dynamic extent of the handler of the continuation
	  prompt of the initial continuation, the exception is raised
	  in the continuation of the call
	  to <code>call-in-initial-continuation</code>.</p>
	<p>This extends the semantics of <code>raise</code></p>.
      </dd>
    </dl>

    <h3>Promises</h3>

    <p><dfn>Promises</dfn> are objects that can be <dfn>forced</dfn>
      to deliver values or raise exceptions.</p>

    <dl class="entries">
      <dt class="syntax"><code>(delay <span class="token">body</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> must be a body.</p>
	<p><i>Semantics:</i> Evaluates to a promise that behaves as
	  follows when forced in a continuation: If the promise
	  already has delivered values, the same values are delivered
	  again, and if the promise already has raised an exception,
	  the same exception is raised again in the continuation.
	  Otherwise, <code><span class="token">body</span></code> is
	  evaluated in an initial continuation.  The parameterization
	  of the initial continuation is the same as the
	  parameterization of the continuation of the
	  original <code>delay</code> expression.  When values are
	  delivered to the initial continuation and the promise still
	  hasn't delivered values or has raised an exception, the
	  values are delivered to the continuation in which the
	  promise was forced.  Otherwise, the already delivered values
	  are delivered again, or the already raised exception is
	  raised again in the forcing continuation.  When an exception
	  is raised in the dynamic extent of the handler of the
	  continuation prompt of the initial continuation and the
	  promise still hasn't delivered values or has raised an
	  exception, the object is raised in the continuation in which
	  the promise was forced.  Otherwise, the already delivered
	  values are delivered again, or the already raised exception
	  is raised again in the forcing continuation.</p>

	<p>If a call to <code>force</code> occurs in tail context
	  during the evaluation
	  of <code><span class="token">body</span></code> it is
	  effectively a tail call.</p>

	<p>All operations involved in forcing except for the
	  evaluation of the body are required to be atomic.</p>

	<p><i>Note: </i> The extra requirement about calls
	  to <code>force</code> in tail contexts makes the
	  extra <code>delay-force</code> syntax
	  of <cite>R<sup>7</sup>RS</cite> (see
	  also <a href="van-tonder"><cite>SRFI 45</cite></a>, where it
	  is called <code>lazy</code>) unnecessary.</p>
      </dd>

      <dt class="procedure"><code>(make-promise <var>obj</var> &hellip;)</code></dt>
      <dd>
	<p>Returns a promise that, when forced in a continuation,
	delivers the values <code><var>obj</var></code> &hellip; to the
	continuation.</p>
	<p><i>Note:</i>
	  <cite>R<sup>7</sup>RS</cite> includes the description of a
	  one-argument procedure also named <code>make-promise</code> that
	  behaves as the <code>make-promise</code> procedure defined
	  here when applied to a single non-promise object.  As the
	  semantics of <code>make-promise</code>
	  in <cite>R<sup>7</sup>RS</cite> makes it mostly useless and
	  does not allow the obvious generalization to multiple
	  values, we have decided to break compatibility for the
	  better.
	</p>
      </dd>

      <dt class="procedure"><code>(promise? <var>obj</var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
	promise, and <code>#f</code> otherwise.</p>
      </dd>

      <dt class="procedure"><code>(force <var>promise</var>)</code></dt>
      <dd>
	<p>The <code>force</code> procedure
	forces <code><var>promise</var></code> in the continuation of
	the call to <code>force</code>.</p>
      </dd>
    </dl>

    <p><i>Note:</i>
      <cite>R<sup>7</sup>RS</cite> includes the unfortunate
      requirement that the body of a <code>delay</code> form has to be
      evaluated in the dynamic environment of the call
      to <code>force</code>.  This makes the result of forcing a
      promise dependent on the time when the promise is forced even in
      purely functional code.  As has already been observed Marc
      Feeley during the discussion period of <cite>SRFI 39</cite>, the
      correct semantics would have been to evaluate the body of
      a <code>delay</code> form in the parameterization of that form.
      The <code>delay</code> syntax defined in this specification has
      the correct semantics and is breaking compatibility
      with <cite>R<sup>7</sup>RS</cite> for what we think is the
      better.  The semantics defined here also work well in the
      presence of capturing and applying continuations.  In fact, with
      regard to the dynamic environment, the semantics of promises are
      now equivalent to that of threads.</p>

    <h3>Exceptions</h3>

    <p>Conceptionally, each continuation contains at least one
      otherwise inaccessible exception handler stack continuation
      mark, whose value is a list of exception handlers,
      which are one-argument procedures.  The <dfn>exception handler
      stack</dfn> of a continuation is the vale of the most recent
      exception handler stack continuation mark in the continuation.
      The exception handler stack of the current continuation is
      the <dfn>current exception handler stack</dfn>.
      The <dfn>current exception handler</dfn> is the first element of
      the current exception handler stack.  An exception handler
      (procedure) is <dfn>installed</dfn> in a continuation by
      recording the exception handler stack of the continuation,
      constructing a new exception handler stack by prepending the
      exception handler to be installed to the recorded exception
      handler stack and annotating the continuation with an exception
      handler stack continuation mark whose value is the new exception
      handler stack.  The most recent exception handler
      is <dfn>removed</dfn> in a continuation by recording the
      exception handler stack of the continuation, constructing a new
      exception handler stack by removing the first element of the
      recorded exception handler stack and annotating the continuation
      with an exception handler stack continuation mark whose value is
      the new exception handler stack.</p>

    <dl class="entries">
      <dt class="procedure"><code>(with-exception-handler <var>handler</var> <var>thunk</var>)</code></dt>
      <dd>
	<p><code><var>Handler</var></code> must a procedure and and should accept one argument.</p>
	<p>Installs <code><var>handler</var></code> in the
	  continuation to the call
	  to <code>with-exception-handler</code>,
	  calls <code>thunk</code> with no arguments, and delivers the
	  resulting values to the continuation of the call
	  to <code>with-exception-handler</code>.
	</p>
	<p>If a call
	  to <code>with-exception-handler</code> occurs in a tail
	  context. the call to <code><var>thunk</var></code> is also in a tail
	  context.</p>
	<p><i>Note:</i> The tail context requirement is neither
	  in <cite>R<sup>6</sup>RS</cite>, nor
	  in <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
      <dt class="procedure"><code>(current-exception-handlers)</code></dt>
      <dd>
	<p>Returns a newly allocated list containing the handlers of
	  the current exception handler stack with the most recently
	  installed handlers coming first.</p></dd>
      <dt class="procedure"><code>(current-exception-handler)</code></dt>
      <dd><p>Returns the current exception handler.</p>
      </dd>
      <dt class="procedure"><code>(raise <var>obj</var>)</code></dt>
      <dd>
	<p>Raises a <dfn>non-continuable exception</dfn> as follows:
	  The current exception handler is recorded and then the most
	  recent exceptin handler is removed in the continuation
	  to the call to <code>raise</code>.  The recorded exception
	  handler is then invoked on <code><var>obj</var></code>.  If
	  this invocation returns, a non-continuable exception with
	  condition type <code>&amp;non-continuable</code> is raised
	  in the continuation of the call to <code>raise</code>.
	</p>
	<p>If there is no current exception handler because the
	  current exception handler stack is empty, the current
	  continuation is instead aborted to the most recent
	  continuation prompt tagged with the default continuation
	  prompt and its handler invoked on a thunk that, when called,
	  raises <code><var>obj</var></code>.</p>
	<p><i>Note:</i> The current exception handler stack becomes
	  empty if the initial exception handler returns after having
	  been invoked on a non-<code>&amp;serious</code> condition,
	  and causing a <code>&amp;non-continuable</code> condition to
	  be raised.</p>
      </dd>
      <dt class="procedure"><code>(raise-continuable <var>obj</var>)</code></dt>
      <dd>
	<p>Raises a <dfn>continuable exception</dfn> as follows:
	  The most recent continuation frame in the continuation to
	  the call to <code>raise-continuable</code> is annotated with an
	  exception handler stack continuation mark whose value is the
	  current handler stack with the first element removed.  The
	  previously first element is then invoked
	  on <code><var>obj</var></code> and its values are returned.</p>
	<p>If there is no current exception handler because the
	  current exception handler stack is empty, the current
	  continuation is instead aborted to the most recent
	  continuation prompt tagged with the default continuation
	  prompt and its handler invoked on a thunk that, when called,
	  raises <code><var>obj</var></code>.</p>
	<p>If a call to <code>raise-continuable</code> occurs in a
	  tail context, the call to the current exception handler is
	  also in a tail context.</p>
	<p><i>Note: </i> The tail context requirement is neither
	  in <cite>R<sup>6</sup>RS</cite>, nor
	  in <cite>R<sup>7</sup>RS</cite>.  It is
	  in <cite>SRFI 18</cite>,
	  whose <code>raise</code> corresponds
	  to <code>raise-continuable</code>
	  in <cite>R<sup>6</sup>RS</cite>
	  and <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
      <dt class="syntax"><code>(guard
	  (<span class="token">variable</span> <span class="token">cond
	  clause<sub>1</sub></span> <span class="token">cond
	    clause<sub>2</sub></span>) <span class="token">body</span>)</code></dt>
      <dt class="entry"><code>=&gt;</code><span class="type">auxiliary syntax</span></dt>
      <dt class="entry"><code>else</code><span class="type">auxiliary syntax</span></dt>
      <dd>
	<p><i>Syntax:</i> Each <code><span class="token">cond
	  clause</span></code> is as in the specification
	  of <code><span class="token">cond</span></code>.  <code><span class="token">Variable</span></code>
	  must be an identifier and <code><span class="token">body</span></code> a body.</p>
	<p><i>Semantics:</i> Installs an exception handler as
	  described below in the continuation of
	  the <code>guard</code> expression and
	  evaluates <code><span class="token">body</span></code>.  The
	  installed exception handler captures and records the current
	  continuation delimited by the default prompt tag.  It then
	  aborts to the continuation of the <code>guard</code>
	  expression or to the most recent continuation prompt tagged
	  with the default prompt tag, whatever comes first.  It then
	  binds the raised object
	  to <code><span class="token">variable</span></code> and
	  within the scope of that binding evaluates the clauses as if
	  they were the clauses of a <code>cond</code> expression.  If
	  every <code><span class="token">cond clause</span></code>
	  evaluates to <code>#f</code> and there is
	  no <code>else</code> clause, the recorded continuation is
	  reinstated with the most recent exception handler removed
	  and a continuable exception with <code>obj</code> is raised
	  in the resulting continuation.  Otherwise, the resulting
	  values of the equivalent <code>cond</code> expression are
	  delivered to the aborted continuation.</p>
	<p>If a <code>guard</code> expression is in tail context, the
	  last expression
	  in <code><span class="token">body</span></code> is in tail
	  context as well.  The final expression in
	  a <code><span class="token">cond clause</span></code> is in
	  a tail context if the <code>guard</code> expression itself
	  is.</p>
	<p><i>Note:</i> The tail context requirement on the body of
	  a <code>guard</code> expression is neither
	  in <cite>R<sup>6</sup>RS</cite>, nor
	  in <cite>R<sup>7</sup>RS</cite>.</p>
      </dd>
    </dl>

    <h3>Threads</h3>

    <dl class="entries">
      <dt class="entry"><code>(thread <span class="token">body</span>)</code><span class="type">syntax</span></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Body</span></code> must be a body.</p>
	<p><i>Semantics:</i> Operationally equivalent to
	  evaluating <code>(make-thread (lambda
	  () <span class="token">body</span>))</code>.  The initial
	  continuation is an initial continuation as defined above.
	  The parameterization of the initial continuation is the same
	  as the parameterization of the continuation of
	  the <code>thread</code> expression.  When an exception is
	  raised in the dynamic extent of the handler of the initial
	  continuation prompts, a condition with
	  type <code>&amp;uncaught-exception</code> and the raised
	  object as its reason is stored in
	  the <code>end-exception</code> of the thread before the
	  thread is finally terminated.  When values are delivered to
	  the initial continuation, the values are stored in
	  the <code>end-result</code> of the thread before the thread
	  is finally terminated.</p>
	<p>This extends the semantics of <code>raise</code></p>.
	<p><i>Note:</i> This also defines the initial continuation of
	  a thread created by invoking the <code>make-thread</code>
	  procedure in <cite>SRFI 18</cite>.</p>
	<p><i>Note:</i> As threads inherit the parameterization of
	  when they are created, a <code>thread</code> expression
	  conveys the meaning better than a call
	  to <code>make-thread</code>.</p>
      </dd>
    </dl>

    <h2 id="implementation">Implementation</h2>

    <h3>Portability</h3>

    <p>Implementing the control operators presented in this SRFI
      solely in terms of the facilities provided in <cite>R<sup>6</sup>RS</cite> or
      <cite>R<sup>7</sup>RS</cite> is not possible.</p>

    <h3>Sample Implementation</h3>

    <p>The sample implementation accompanying this SRFI demonstrates
      how the control operators can be implemented on top of a small
      set of primitives.  If in doubt, it favors simplicity and
      clarity over speed.</p>

    <p>The small set of primitives that have to be provided are as follows:</p>

    <dl class="entries">
      <dt class="procedure"><code>(%call-with-current-continuation <var>proc</var>)</code></dt>
      <dd>
	<p>It is an error if <code><var>proc</var></code> is not a
	procedure taking a single argument.</p>
	<p>Calls <code><var>proc</var></code> with the current undelimited continuation.</p>
	<p>If a call to <code>%call/cc</code> occurs in a tail
	context, the call to <code><var>proc</var></code> is also in a
	  tail context.</p>
	<p>An undelimited continuation is represented by a
	  procedure <code><var>k</var></code> that, when it is later
	  called, abandons whatever undelimited continuation is in
	  effect at that later time and instead reinstates the
	  continuation that is represented by it.</p>

	<p><i>Note:</i> The
	  primitive <code>%call-with-current-continuation</code> does
	  neither support <code>dynamic-wind</code>, nor continuation
	  barriers.</p>
      </dd>
      <dt class="procedure"><code>(%call-in-continuation <var>k</var> <var>thunk</var>)</code></dt>
      <dd>
	<p>Abandons whatever undelimited continuation is in effect,
	  and calls <code><var>thunk</var></code> with the undelimited
	  continuation represented by <code><var>k</var></code> as the
	  continuation of the call.</p>
      </dd>
      <dt class="procedure"><code>(%continuation=? <var>k<sub>1</sub></var> <var>k<sub>2</sub></var>)</code></dt>
      <dd>
	<p>Returns <code>#t</code> if the undelimited continuation
	  represented by <code><var>k<sub>1</sub></var></code> is the
	  same as the undelimited continuation represented
	  by <code><var>k<sub>2</sub></var></code>,
	  and <code>#f</code> otherwise.</p>
	<p><i>Note:</i> Procedure equivalence with respect to the
	  standard predicates <code>eq?</code>, <code>eqv?</code>,
	  and <code>equal?</code> is unspecified at least in some
	  versions of the Scheme programming language.</p>
      </dd>

      <dt class="syntax"><code>(%case-lambda-box <span class="token">expression</span> [<span class="token">formals</span>
	  <span class="token">body</span>] ...)</code></dt>
      <dd>
	<p><i>Syntax:</i>
	  <code><span class="token">Expression</span></code> must be
	  an
	  expression, the <code><span class="token">formals</span></code>s
	  must be formal parameter lists
	  and the <code><span class="token">body</span></code>s must be
	  bodies.</p>

	<p><i>Semantics:</i>
	  When a <code>%case-lambda-box</code> expression is evaluated,
	  it first
	  evaluates <code><span class="token">expression</span></code>,
	  stores the resulting value in a new location, and then
	  returns a procedure that when later called with some
	  arguments behaves as if the procedure were created by
	  evaluating <code>(case-lambda [<span class="token">formals</span> <span class="token">body</span>] ...)</code>
	  and that is tagged with the new location.</p>
      </dd>

      <dt class="procedure"><code>(%case-lambda-box-ref <var>proc</var> <var>obj</var>)</code></dt>
      <dd>
	<p>If <var>proc</var> is a procedure tagged with a location,
	  the <code>%lambda-box-ref</code> procedure returns the value
	  stored in this location, and <code>obj</code> otherwise.</p>
      </dd>

    </dl>

    <h3>Other Implementations</h3>

    <p>A lot of the control operators of this SRFI are natively
    implemented in Racket.  A high-performance implementation of
    continuation marks is described in <a href="#flatt"><cite>Compiler
    and runtime support for continuation marks</cite></a>.</p>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>This SRFI borrows heavily from Racket's collection of control
    operators.</p>

    <p>The sample implementation builds upon the ideas presented
      in <a href="#dybvig"><cite>A Monadic Framework for Delimited
      Continuations</cite></a> and found in Racket's CS
      implementation.</p>

    <p>Finally, I would like to thank Arthur A. Gleckler for
      <a href="https://srfi-email.schemers.org/srfi-224/msg/16888913/">encouraging me</a> to write a SRFI covering delimited
      continuations.</p>

    <h2 id="references">References</h2>

    <ol class="bibliography">
      <li id="chezscheme"><p><a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a>.</p></li>
      <li id="dybvig">
	<p>R. Kent Dybvig, Simon Peyton Jones, and Amr
	  Sabry: <cite>A monadic framework for delimited
	    continuations</cite>, Journal of Functional Programming, Volume
	  17, Issue 6, November 2007,
	  pp. 687-730. DOI: <a href="https://doi.org/10.1017/S0956796807006259">10.1017/S0956796807006259</a>.</p>
      </li>
      <li id="feeley1">
	<p>Marc
	Feeley: <a href="https://srfi.schemers.org/srfi-18/srfi-18.html"><cite>SRFI
	18: Multithreading support</cite></a>.</p>
      </li>
      <li id="feeley2">
	<p>Marc
	Feeley: <a href="https://srfi.schemers.org/srfi-39/srfi-39.html"><cite>SRFI
	39: Parameter objects</cite></a>.</p>
      </li>
      <li id="flatt">
	<p>Matthew Flatt, R. Kent Dybvig: <cite>Compiler and runtime
	  support for continuation marks</cite>, PLDI 2020:
	  Proceedings of the 41st ACM SIGPLAN Conference on
	  Programming Language Design and Implementation, June 2020, pp. 45-58. DOI: <a href="https://doi.org/10.1145/3385412.3385981">
	    10.1145/3385412.3385981</a>.</p></li>
      <li id="kawai">
	<p>Shiro Kawai, John Cowan, Thomas
	Gilray: <a href="https://srfi.schemers.org/srfi-158/srfi-158.html"><cite>SRFI
	158: Generators and Accumulators</cite></a>.</p>
      </li>
      <li id="r7rs">
	<p><a href="https://github.com/johnwcowan/r7rs-work/blob/master/R7RSHomePage.md">R7RS Home Page</a>.</p>
      </li>
      <li id="racket">
	<p><a href="https://racket-lang.org/">Racket</a>.</p>
      </li>
      <li id="shinn">
	<p>Alex Shinn, John Cowan, Arthur
	  A. Gleckler: <a href="https://small.r7rs.org/attachment/r7rs.pdf"><cite>Revised<sup>7</sup>
	  Report on the Algorithmic Language Scheme</cite></a>.</p>
      </li>
      <li id="sperber">
	<p>Michael Sperber, R. Kent Dybvig, Matthew Flatt,
	  Anton van Straaten, Robby Findler, and Jacob
	  Matthews: <cite>Revised<sup>6</sup> Report on the Algorithmic
	    Language Scheme</cite>. Journal of Functional Programming,
	  Volume 19, Supplement S1, August 2009,
	  pp. 1-301. DOI: <a href="https://doi.org/10.1017/S0956796809990074">10.1017/S0956796809990074</a>.</p>
      </li>
      <li id="kawai">
	<p>André van Tonder: <a href="https://srfi.schemers.org/srfi-45/srfi-45.html"><cite>SRFI
	45: Primitives for Expressing Iterative Lazy Algorithms</cite></a>.</p>
      </li>

    </ol>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2021 Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
